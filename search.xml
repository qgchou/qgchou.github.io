<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql的基本使用]]></title>
    <url>%2F2018%2F05%2F04%2Fmysql-basic%2F</url>
    <content type="text"><![CDATA[deleteDELETE FROM table_name [WHERE Clause] updateUPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] 参考 MySQL 教程]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql删除重复记录]]></title>
    <url>%2F2018%2F04%2F23%2Fmysql%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[执行报错：1093 - You can&apos;t specify target table &apos;A&apos; for update in FROM clause 原因是：更新数据时使用了查询，而查询的数据又做了更新的条件，mysql不支持这种方式。oracel和msserver都支持这种方式。 有个表A，里面有些记录是重复的，现在要去重，只要表A的字段col1,col2是相同的，则认为是重复的记录，此外表A里还有个flag字段，标识这条记录是否处理过，flag=1表示处理过了，flag=0表示未处理，flag=1的记录，如果有重复记录，这些重复记录也不需要再进行处理。 找资料，有两种解决方案： delete from A where id in (select id FROM (SELECT id from A GROUP BY col1, col2, start_time,host_name HAVING count(*) &gt; 1) a) and id not in (SELECT min(id) FROM (select min(id) as id from A GROUP BY col1, col2 HAVING count(*) &gt; 1) b); 第二种： delete from A where id in (select id FROM (SELECT id from A GROUP BY col1, col2 HAVING count(*) &gt; 1) a) and flag=0; delete from A where id in (select id FROM (SELECT id from A GROUP BY col1, col2 HAVING count(*) &gt; 1) a) and flag=1; 找这个方案的过程中，我遇到文章开关提到的问题，在参考1中找到解决办法。在解法一中，我没有考虑到flag的因素，因为库里的大部分数据都没有处理，而且我觉得有重复记录的记录，其flag是一样的，那么都处理过了，要么都没处理。我的做法是，发现有重复记录时，只保留id最小的那条记录。解决二中，我觉得留下id小的没意义，考虑了下flag，我是做两步处理的，第一步是去掉那些重复记录中，flag=0的那些重复，因为我觉得有重复记录的记录，有一个备份的flag=1时，那些flag=0的备份就没处理的意义了，先去掉这些记录，再处理那些多个flag=1的重复记录。 方案一有点问题，有部分重复没有没有找出来，我也不知道原因。用方案一处理后，我看看有没有重复： SELECT * from A GROUP BY col1,col2 HAVING count(*) &gt; 1; 发现有一条重复记录r。 SELECT * from A where col1=&apos;test1&apos; and col2=&apos;test2&apos;; 这条记录重了4份，id1,id2,id3,id4。 在解决1中： select id FROM (SELECT id from A GROUP BY col1, col2, start_time,host_name HAVING count(*) &gt; 1) a; 我期望是通过上面筛选出 id1,id2,id3,id4，但是这句执行后，只筛选出id最小的id1。因此就不能把id2,id3,id4这三条记录删掉。我还没找到原因呢。2018-4-23 21:3:46。 参考 Mysql删除重复记录，保留id最小的一条]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java小知识点]]></title>
    <url>%2F2018%2F04%2F19%2Fjava%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[BigDecimaljava中BigDecimal的equals与compareTo的区别]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习lombok的使用]]></title>
    <url>%2F2018%2F04%2F17%2Flombok-study%2F</url>
    <content type="text"><![CDATA[java中要使用POJO对象,必须还要写一些getter和setter方法,可能还要写一个构造器、equals方法、或者hash方法.这些方法很冗长而且没有技术含量，我们叫它样板式代码。lombok的主要作用是通过一些注解，消除样板式代码。 idea下要安装lombok插件，不然一些get方法、set方法会报错，log变量也会显示不存在（这个要在类头加注解@Log4j2）。 参考 Java开发中用到的lombok是什么？]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webmagic学习]]></title>
    <url>%2F2018%2F04%2F16%2Fwebmagic-study%2F</url>
    <content type="text"><![CDATA[定位一个元素时可以用xpath，也可以用css选择器。这里可以用到chrome自带的工具： 123Html html = page.getHtml();//Selectable infoNode = html.xpath("//div[@class='k_04']//table[4]");List&lt;Selectable&gt; infoNodes = html.$("div.k_04 table").nodes(); 页面元素的抽取，有三种方式： XPath 正则表达式 CSS选择器 今天我要取 span 中的某个值：要这个评分，span中的值，然后我在jquery选择器的语法中没找到选span值的写法，chrome工具复制得到的是整个span元素，要取里面的text怎么办呢。原来语法是这样的： $(String selector,String attr) 第二个参数，填入属性名就可以了。下面两种写法是等价的： 12//String goal = html.xpath("//*[@id=\"anim_score_info\"]/span[1]/text()").get();//得分String goal = html.$("#anim_score_info &gt; span.points_text","text").get(); 参考 4.2 使用Selectable抽取元素]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10休眠断网]]></title>
    <url>%2F2018%2F04%2F16%2Fwin10%E4%BC%91%E7%9C%A0%E6%96%AD%E7%BD%91%2F</url>
    <content type="text"><![CDATA[家里的电脑要连公司的电脑，用teamviewer，回家后发现总是连不上。原来在在公司电脑上设置两个地方： 1、网络适配器设置 2、电源设置]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[navicat学习使用]]></title>
    <url>%2F2018%2F04%2F14%2Fnavicat-study%2F</url>
    <content type="text"><![CDATA[公司配了个新电脑。这周我净是配环境去了。环境是勉强能用了，但是这些工具就像武器一样，凑合着用是一回事，用得称手是另外一回事，这得在工作中不断去打磨自己的武器，才能让武器变得称心如意。这其实是要花不少时间精力的，所以网上看一些工具的教程时，作者常常会放出自己的配置文件，例如eclipse的配置文件，emacs配置文件等。因为现在很多工具是非常庞大的，功能非常强大的，就像一间精装修的房子，领包入住是没问题的，但是你要把这里当家，一天天、一年年地要住里面的话，一个懂生活的人会认真去打磨家的每个细节。不同于家里的房子，老一辈的人买了房安了家，就会在这个房子住一辈子。电脑环境呢？我们换电脑的频率还是比换房子的频率高很多的，得用公司的电脑啦，自己的电脑坏了换新电脑啦，自己的电脑配置太低了要换电脑啦，等等。所以工作中，有很多人到公司去上班时，还是坚持用自己的电脑。言归正传，说到navicat。 以前做项目中我只用到mysql数据库，用的客户端工具有 navicat 或 sqlyog，现在公司的项目要连oracle唉，然后我听说naviact能连oracle，果然，是有个navicat for oracle 这个版本。我以前用的是navicat for mysql版本。居然是有这个区别啊。没话说，我找到个资源 Navicat for Oracle 绿色版 连接 Oracle 12c ，也顺利连上了oracle。 然后今天我clone下来另一个项目，数据库是mysql。。。我找了下我的百度云，里面是有个navicat for mysql的，然后我连了mysql数据库，不错，也是能用的。但是还是感觉怪怪的，查数据库是个很频繁的操作，要用到两个工具，我不能忍。我用的idea编辑器其实是内置数据库客户端的，既能连oracle，又能连mysql，但是感觉自带的不够方便，比如保存sql脚本之类的常用操作（据说也可以？）。我对idea自带数据库客户端了解不够，还是决定要用第三方工具。 然后我听同事说有个工具叫 Navicat Premium ，这个既能连mysql，又能连oracle，这么棒？以前用过navicat，感觉很方便啊，果断决定要上手 Navicat Premium 。找到一个不错的资源 Navicat Premium 12.0.18安装与激活 ，根据文章来操作，记得要先安装 Microsoft Visual C++ 2017 Redistributable (x86 &amp; x64) 。然后我的工具就激活了，连了下mysql，可以。连oracle，又卡壳了。我把之前装navicat for oracle时用到的 instantclient_12_1 和 sqlplus.exe 取来，然后在这里配上：然后在连接配置界面点“连接测试”，报错 “oracle library is not loaded” ，我把 “oci.dll” 换成安装路径下自带的 “oci.dll” ，还是不行，反复撞了几回墙，我沉默了。认真看了这句报错，我觉得应该是从navicat for oracle 那里拷过来的 oracle library 不对，可能是版本有问题，反正就是不对。最后，还是 google 大法好。我把Navicat Premium 的版本号和位数，一起去搜。第一条就是正确答案：答案的链接是： Navicat Premium 12连接Oracle时提示oracle library is not loaded的问题解决我装了个正确版本的“Instant Client”，然后把 oci.dll 地址指向新安装的这个。然后我的oracle就能正确连接了。]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器学习]]></title>
    <url>%2F2018%2F04%2F14%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cron表达式学习]]></title>
    <url>%2F2018%2F04%2F14%2Fcron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：Seconds Minutes Hours DayofMonth Month DayofWeek Year 或Seconds Minutes Hours DayofMonth Month DayofWeek 每两分钟执行一次： * */2 * * * ? 从10秒开始，每1分钟执行一次： 10 */1 * * * ? 每5秒执行一次： 0/5 * * * * ? 每周二、四、日的晚上20点到23点，每5分钟执行一次 0 0/5 20-23 ? * 2,4,7 每天1点到19点，每小时的第一分钟执行一次 0 1 1-19 * * ? “”字符被用来指定所有的值。如：”“在分钟的字段域里表示“每分钟”。 “?”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“?” “-”字符被用来指定一个范围。如：“10-12”在小时域意味着“10点、11点、12点”。 “,”字符被用来指定另外的值。如：“MON,WED,FRI”在星期域里表示”星期一、星期三、星期五”。 “/”字符用于指定增量。如：“0/15”在秒域意思是每分钟的0，15，30和45秒。“5/15”在分钟域表示每小时的5，20，35和50。符号“”在“/”前面（如：/10）等价于0在“/”前面（如：0/10）。记住一条本质：表达式的每个数值域都是一个有最大值和最小值的集合，如：秒域和分钟域的集合是0-59，日期域是1-31，月份域是1-12。字符“/”可以帮助你在每个字符域中取相应的数值。 参考 Spring集成Quartz定时任务框架介绍和Cron表达式详解 cron表达式详解]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习使用eclipse]]></title>
    <url>%2F2018%2F04%2F14%2Feclipse-study%2F</url>
    <content type="text"><![CDATA[快捷键我目前用的idea把keymap设成eclipse，这样我在使用idea时，还能使用eclipse快捷键。 查看代码层次结构： ctrl + T 用文件名查找某个文件： ctrl + shift + R 用类名查找某个类： ctrl + shift + T 查看某个类的继承实现层次关系： F4 查看某个方法的调用层次关系：ctrl + alt + H 查看某个变量在工程中哪些地方使用到：ctrl + G 打开 Outline 大纲视图：ctrl + O]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俞敏洪《人要像树一样活着》]]></title>
    <url>%2F2018%2F04%2F14%2F%E4%BF%9E%E6%95%8F%E6%B4%AA%E3%80%8A%E4%BA%BA%E8%A6%81%E5%83%8F%E6%A0%91%E4%B8%80%E6%A0%B7%E6%B4%BB%E7%9D%80%E3%80%8B%2F</url>
    <content type="text"><![CDATA[以前在网上看过俞敏洪的演讲，《人要像树一样活着》，非常感动。 人的生活方式有两种， 第一种方式是像草一样活着， 你尽管活着，每年还在成长， 但是你毕竟是一棵草， 你吸收雨露阳光， 但是长不大。 人们可以踩过你， 但是人们不会因为你的痛苦，而他产生痛苦； 人们不会因为你被踩了，而来怜悯你， 因为人们本身就没有看到你。 所以我们每一个人， 都应该像树一样的成长， 即使我们现在什么都不是， 但是只要你有树的种子， 即使你被踩到泥土中间， 你依然能够吸收泥土的养分， 自己成长起来。 当你长成参天大树以后， 遥远的地方，人们就能看到你； 走近你，你能给人一片绿色。 活着是美丽的风景， 死了依然是栋梁之才， 活着死了都有用。 当自己有硬实力了，别人就不会忽视你，因为你是一颗树了，别人的眼光无法从你身上越过，因为你是一个不可忽视的存在了。想想许三多从草原五班刚到钢七连时，被人当空气，最后成了代理班长，然后到老A，成长为了兵王。得不断提高自己的实力，“想到”和“得到”，中间有个“做到”。加油吧。 我忽然想到邻国的金大元帅，一穷二白的朝鲜在国际上不被待见，闷声搞核武器，这时国际社会就再也不能忽视金帅了，美国也不敢小视金帅了。当然这种极端的做法我们政治正确的人都是表示反对的，说这是核敲诈。国际问题，要提高国际地位，还是得遵照一定的法则，这种走极端的做法我也是非常反对的，但是客观上来讲，国际社会再也不能忽视朝鲜了，开始正视朝鲜的国际诉求了。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新电脑上配置环境]]></title>
    <url>%2F2018%2F04%2F14%2F%E4%B8%80%E5%8F%B0%E6%96%B0%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[公司配了台新的笔记本。然后我要在这台机器上办公，所以得在新机器上配一下我的环境。 一些软件微信、QQ、蓝灯、FSCapture、teamviewer、everything、360安全卫士、有道词典、chrome、sublime、idea、navicat、git、secureCRT、SwitchHosts、Fiddler、射手播放器、搜狗五笔、印象笔记、百度云盘、jdk、360压缩、foxmail、githubDesktop。然后是公司内部使用的一套软件。 hexo 和 sublimehexo博客我之前用得挺顺溜的，也感觉有些作用，要在新机器上配下hexo。有时我想这些博客写在自己的印象笔记不也可以吗？写在github博客就是public权限了，权限放得越开，管理成本越小，人生于天地间，要是能同山川河流一样坦荡，我觉得是件很棒的事。言归正传，怎么在新机器上部署hexo呢。我的博客编辑器用的是sublime，先整sublime，就是一堆插件，我在新机上安装sublime后，把原机器上的插件文件夹下的插件全拷过来了。把这个文件夹全拷过来就行了。然后我的markdown及其实时预览的插件在新机上就能用了。hexo博客我托管在github上，先把这个仓库clone到本地。 https://github.com/qgchou/qgchou.github.io.git 然后要是安装hexo的一些命令了。这里可以参考我的另外一篇关于hexo的文章《hexo学习》。先要安装npm，然后才是hexo： npm install hexo npm install npm install hexo-deployer-git Node.js 官方源默认是： http://registry.npmjs.org， 但是由于在国外，有时候无法下载任何软件。可以暂时使用淘宝提供的源，淘宝源官网：http://npm.taobao.org/ 另外一篇文章 使用 Github 空间搭建 Hexo 技术博客 说安装hexo只用一条命令： cnpm install -g hexo-cli 另外，我的博客发布用了一段js脚本，得要装一下js插件，自动备份Hexo博客源文件 npm install --save shelljs 上面一番设置后，就可以愉快地用sublime写博客了。公司电脑上公司的项目是用git，这里的博客也是用git，我想用不同的签名。用命令： git config --local user.name &quot;Your Name&quot; git config --local user.email you@example.com 在下面两个仓库设置一下本仓库的签名就可以了：]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN原理学习]]></title>
    <url>%2F2018%2F04%2F13%2Fvpn-read%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
      <tags>
        <tag>占坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ibase4j]]></title>
    <url>%2F2018%2F04%2F13%2Fibase4j-study%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/qgchou/iBase4J1、从群文件中下载一些工具(咦，上面用本地目录的方式也挺方便的，但是一个问题是，每次hexo clean，都会重新上传图片到服务器，白白耗费流量)于是我删了上图，换成图床：解压后放在D盘：2、配置nginx3、运行脚本文件run.cmd，这样就启动了下图中的4个服务nginx启动后，访问localhost可看到下面页面：4、将工程clone到本地，并导入到intellij idea，执行sql脚本，建立数据库。5、配置好idea的maven环境，点下图按钮，建立project之间的依赖6、运行参数配置7、解压war包文件到对应的tomcat/webapps/ROOT目录，每个tomcat只放一个项目（有用？）：解压iBase4J-SYS-Service/target/iBase4J-SYS-Service.war 到tomcat1；解压iBase4J-SYS-Web/target/iBase4J-SYS-Web.war 到tomcat28、先后启动service和web9、访问 localhost ，输入账号密码admin/111111，可看到：访问 localhost:8088/swagger-ui.html 查看Restful接口：访问 http://localhost:8085/druid ，输入账号密码druid/druid，可查看druid sql监控： 完毕，感谢分享，感谢开源！ ibase4j 只是搭了个架子，如果想用于生产，可参考另一较成熟的开源框架zheng：https://github.com/qgchou/zheng.git zheng的文档更全]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[七牛云的使用]]></title>
    <url>%2F2018%2F04%2F09%2F%E4%B8%83%E7%89%9B%E4%BA%91-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我的hexo博客用了七牛的云存储作为图床，有点不爽的是，图片的域名是七牛给随机生成的一个，我的叫 owyvgfyba.bkt，这是什么鬼啊，不能忍。换成自己的域名呢。七牛云是可以绑定自己的域名的，不过这里要求域名得进行过ICP备案，漫长的等待，也好了。七牛云可以建多个存储空间，在绑定域名时，实际就是把域名绑定到某个存储空间。在七牛云的网站进行“绑定域名”后，这没完，还要配置CNAME，见参考1。然后，这个存储空间的图片就可以用自己的域名来访问了。配置好后，如下图：然后看我用自定义域名访问：明显比以前高大上些了。 我按参考1配置后，用自己的域名访问不了，这个地方：开始时不是显示成功的，而是显示“等待CNAME”，我百思不得其解，盗个图：然后我在FAQ找到参考2的那篇文章，我用dig工具看了下，觉得可能是我的dns有问题，qgchou.top是我是阿里云上注册的，上去一看，提示我的这个域名的dns不正确，阿里云有文章指导，见参考3。然后，就好了，就可以用我的域名访问我在七牛云存储的图片了。 参考 如何配置域名的 CNAME 为什么做了 CNAME 解析还是显示请配置 CNAME 万网域名修改 DNS 方法 七牛云存储域名配置]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ant学习]]></title>
    <url>%2F2018%2F04%2F08%2Fant-study%2F</url>
    <content type="text"><![CDATA[ant的配置文件是build.xml，它由一个project组成，而一个project又可分为许多 target , target 再细分成许多task，每个task都是通过一个实现特定接口的java类来实现的。 每个项目下可以定义很多目标（target元素），这些目标之间可以有依赖关系，当执行这类目标时，需要执行他们所依赖的目标。每个目标中定义多个任务。任务定义了Ant的实际执行的命令。Ant中的任务可以分为3类，核心任务（ant自带的），可选任务，用户自定义任务。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于互联网彩票]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%85%B3%E4%BA%8E%E4%BA%92%E8%81%94%E7%BD%91%E5%BD%A9%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[彩票彩票，是以合法形式、公平原则，重新分配社会的闲散资金，协调社会的矛盾和关系，这使得彩票有一种特殊的地位和价值。国家发行彩票的目的是筹集社会公众资金，资助福利、体育等公众事业发展的。财政部是彩票的主管机关。彩票的发行需经财政部审核同意后报国务院批准的，由国务院批准的彩票发行机构发行，其他任何部门无权批准发行彩票。 中国有“中国福利彩票”和“中国体育彩票”两在系列公众彩票，分别由中国福利彩票发行中心和国家体育总局体育彩票管理中心统一管理、发行和印制，各地区按照公开、公平、公正的原则承销，以促进中国民政福利事业和中国体育事业发展，为中国民政福利事业、中国体育事业筹集资金为目的。 福利彩票就是指筹集社会福利资金为目的而发行的印有号码、图形、或文字供人们自愿购买并按特定规则确定购买人获取或不获取奖金的有价证券。 根据国内彩票行业的有关规定，彩票出售额的50%用于付出彩民的中奖奖金。15%作为彩票发行费用用于付出彩票事务费和代销者的出售费用。35%作为彩票公益金上缴国家用于社会公益事业。以福利彩票为例：公益金有一半上缴中央财政，一半留在地方。上缴中央的部分按60%、30%、5%、5%的比例，分配至社保基金、专项公益金、民政部和国家体育总局。留在地方地，也规定须用于“扶老、助残、救孤、济困、赈灾”五类公益事业。 互联网彩票应主管部门要求，当前各大彩票网站均暂停售彩，可以去附近的实体网点购彩。可以在全国发行彩票的只有中国体育彩票和中国福利彩票。2015年1月，财政部、民政部、国家体育总局联合下发《关于开展私行使用互联网出售彩票行为自查自纠作业有关疑问的告诉》，需要各级单位对彩票市场中私行使用互联网出售彩票的表象，展开自查自纠作业。自2月25日起，因监管机构方针收缩造成的，各网络彩票途径掀起“停售潮”。政策风险对互联网彩票企业的影响立竿见影。停售的缘由，一是互联网彩票发展太快，二是彩票办理部门还没有极好的办法监管到互联网彩票。 触发这次风云的导火索，也许是国家审计署彩票行业的审计。2014年11月，国家审计署出去18个特派办，对全国合计18个省展开彩票资金审计作业。 在线购彩目前处于监管完善的过程。 改革方向下一步加强彩票行业准入资质监管。一方面要建立健全互联网彩票代销准入制度，从资金、人员、技术、管理等各方面设定公开透明的准入资质门槛，分期分批发放准入牌照，在保持市场活跃度的同时，防止形成寡头垄断。另一方面，要建立互联网彩票代销准入后续监管制度，建立并完善定期考核，评价代销商资质和业绩，以及资质年度认证和淘汰机制，实施有进有出的全程监管体系。 何时解禁何时能解禁，至少要两个步骤：一是继续肃清互联网彩票公司违规违法行为；二是重新制定互联网彩票的规则。]]></content>
      <tags>
        <tag>lottery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买体彩]]></title>
    <url>%2F2018%2F04%2F08%2F%E4%B9%B0%E4%BD%93%E5%BD%A9%2F</url>
    <content type="text"><![CDATA[前几天的买了几注北京单场，我问老板有哪些场次可以买，然后老板打印了一堆，足球单场第80401期，有493场比赛，老板从第60场开始把所有的都打印给我了。比赛场次列表：我买的彩票正面，这里的有个0.44元关注一下，也就是说彩资的22%会做公益掉：彩票背面印了购票须知： 去兑奖：我的困惑，在于这个赔率实在没看懂，尤其是这个第二张，从奖金看赔率应该是2.74。然后到到网站上查赔率，北京单场这个彩种在500彩票网和澳客网上均有赔率显示，但怎么都看不到这个2.74。500彩票网上的数据：澳客网上的数据：赔率是浮动的，但是不管是按出票时的赔率算，还是比赛开始前最后的赔率算，都不应该是2.74啊。]]></content>
      <tags>
        <tag>lottery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[体彩大乐透-6亿大派奖]]></title>
    <url>%2F2018%2F04%2F08%2F%E4%BD%93%E5%BD%A9%E5%A4%A7%E4%B9%90%E9%80%8F-6%E4%BA%BF%E5%A4%A7%E6%B4%BE%E5%A5%96%2F</url>
    <content type="text"><![CDATA[那天买彩票，看到传单一则，收藏如下：]]></content>
      <tags>
        <tag>lottery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[travis-ci 学习]]></title>
    <url>%2F2018%2F03%2F20%2Ftravis-ci-study%2F</url>
    <content type="text"><![CDATA[参考2中使用travis-ci，帮助进行基于github的hexo博客的自动化部署过程。“在你push到github仓库后，通过配置文件，它能够执行一系列的脚本（比如编译、构建、测试、推送等）。对于我来说，就可以实现：只要我写完hexo的md博客，推送到github仓库里后，它就能自动帮我构建并推送到github相应的分支上。从而实现了持久化构建，以及我博客的更新。” 参考 使用Travis进行持续集成 hexo持久化构建以及给自有域名github-page上HTTPS]]></content>
      <tags>
        <tag>travis-ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习java线程池]]></title>
    <url>%2F2018%2F03%2F15%2Fjava-thread-pool%2F</url>
    <content type="text"><![CDATA[线程池构造函数： 12public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习B树和B+树]]></title>
    <url>%2F2018%2F03%2F13%2Ftodo-B%E6%A0%91%26B%2B%E6%A0%91%2F</url>
    <content type="text"></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习索引]]></title>
    <url>%2F2018%2F03%2F13%2Ftodo-%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[为什么mysql索引采用B+树]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习HashMap]]></title>
    <url>%2F2018%2F03%2F08%2FHashMap-study%2F</url>
    <content type="text"><![CDATA[通过读源码，来了解下HashMap是如何存放一个元素的。jdk1.7和jdk1.8中HashMap的实现原理是有区别的。先看看jdk1.7的源码中HashMap是如何存放一个元素的。jdk1.7中HashMap存放元素用的方法是 map.put()。当两个key通过HashCode计算相同时，则发生了hash冲突（碰撞），HashMap解决hash冲突的方式是用链表，当发生hash冲突时，将存放在数组中有Entry设置为新值的next。如果hash冲突很多时，HashMap就退化成了链表，查找的性能退化到了O(n)。根本原因在于jdk1.7中，HashMap采用的 位桶+链表 的方式，即常说的散列链表。这里和jdk1.8有别。jdk1.8中，HaspMap在最坏的情况下，查找的性能是O(logN)。因为jdk1.8中采用的是 位桶+链表/红黑树 的方式，也是非线程安全的，当某个位桶的链表长度达到某个阀值时（例如8），这个链表将转化为红黑树。 总结一下 map.put() 后的过程：当向HashMap中put一对键值对时，它会根据 key 的 HashCode 值计算出一个位置（(table.length-1)&amp;hashcode），该位置就是此对象准备往数组中存放的位置。如果该位置没对象，就将此对象直接放在数组当中。若该位置有对象，则沿该位置的链表寻找（判断值是否相同，map不允许键值对重复），若没有值相同的元素，则将该对象放在数组中，该数组的该位置之前存放的对象链接在该对象后面。当key为null时，都放在table[0]中。放入数组前会判断是否要对HashMap扩容。在HashMap扩容后，最消耗性能的点就出现了：原数组中数据必须重新计算其在新数组中的位置，并赋值到新数组中，这就是是resize。resize操作很消耗性能，如果预知要放入HashMap元素的个数，那么合理预设HaspMap的容量能提高性能，例如要放1000个元素，那么 new HashMap(2048)较合适，而不是1024，因为1024*0.75&lt;1000，这样会有一次扩容。 HashMap的数组长度必须是2的幂次方，当数组长度为2的n次幂时，不同的key算得的index相同的概念较小，那么数据在数组上的分布会比较均匀，也就是说碰撞的几率小。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java传参是传值还是传引用？]]></title>
    <url>%2F2018%2F03%2F08%2F%E4%BC%A0%E5%80%BC%26%E4%BC%A0%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[对象一般是按引用传递的，特例：String类型，基本数据类型的包装类，可以认为是传值。 java应用程序有且只有一种参数传递机制，即按值传递。 按值传递意味着，当将一个参数传递给一个函数时，函数接收到的是原始值的一个副本。 按引用传递意味着，当将一个参数传递给一个函数时，函数接收的是原始值的内存地址，而不是值的副本。 之前项目中有两次遇到过这个问题：一次是想在一个函数中修改两个基本数据类型的int值，办法：构建一个数组，将两个int赋给数组的两个元素，在函数中修改数组。另一次，是函数定义中，参数有一个对象引用，在函数中对该引用赋了一个new对象，函数结束后发现引用指向对象未修改。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java静态类]]></title>
    <url>%2F2018%2F03%2F08%2Fjava%E9%9D%99%E6%80%81%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一个类被 static 修饰的情形只有一种，那就是这个类作为静态内部类。静态内部类中可以声明成员变量和方法，静态内部类可以单独初始化。静态内部类的使用场景单独：一般是当外部类需要使用内部类，而内部类无需外部类资源，并且内部类可以单独创建的时候会考虑采用静态内部类的设计。jdk的HashMap源码中我看到了静态内部类的使用。jdk1.8中的HashMap： transient Node&lt;K,V&gt;[] table; 其中Node的定义用了静态内部类： 123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; //……&#125; 在LinkedHashMap中定义结点： 123static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; //……&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习mysql存储引擎]]></title>
    <url>%2F2018%2F03%2F08%2Fmysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[mysql的默认存储引擎是MyISAM，不支持事务也不支持外键，所以一般用InnoDB引擎。相比于MyISAM，InnoDB最大的不同有两点：一是支持事务，二是采用了行级锁。 MyISAM存储引擎只支持表锁，这也是mysql开始的几个版本中唯一支持的锁类型。随着应用对事务完整性和并发性要求的不断提高，mysql才开始开发基于事务的存储引擎，后来慢慢出来支持页锁的BDB存储引擎和支持行锁的InnoDB存储引擎（BDB已经被InnoDB取代），但是MyISAM的表锁依然是使用最广泛的锁类型。表级锁适合于查询为主，只有少量按索引条件更新数据的应用场景。而行级锁更适合于大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理系统（OLTP）。 MyISAMMyISAM在执行查询语句（select）前，会自动给涉及的表加读锁，在执行更新操作（update、delete、insert等）前，会自动给涉及的表加写锁，这个过程不需要用户干预。MyISAM是写进程优先获得锁，MyISAM认为写请求一般会比读请求更重要。这也是MyISAM不适合于有大量更新操作的查询操作的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。幸好可以通过 一些设置来调节MyISAM的调度行为： 指定启动参数 low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。 执行命令 set low-priority-update=1，使该连接发出的更新请求优先级降低。 指定 insert、update、delete语句的 low_priority属性，降低该语句的优先级。 给系统参数 max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，mysql就暂时将写请求的优先级降低，给读进程获得锁的机会。]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务学习]]></title>
    <url>%2F2018%2F03%2F08%2F%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[数据库事务的四个特性：ACIDA：Atomicity 原子性C：Consistency 一致性I：Isolation 隔离性D：Durability 持久性 事务的隔离级别未提交读：Read uncommitted提交读：Read Committed可重复读：Repeatable Read可串行化：Serializable 大多数数据库系统的事务隔离级别是Read Committed，而mysql的默认事务隔离级别是Repeatable Read。 多线程并发读取数据一般会引发三个问题 脏读：dirty reads一个事务处理过程中读取了另一个未提交的事务中的数据 不可重复读：non-repeatable reads对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改并提交了数据。 幻读：phanton read现象：例如，事务T1对一个表中所有行的某个数据项item做了从“1”修改为“2”的操作。此时，事务T2对这个表插入了一行数据，其item数据项的数据值还是“1”，并且提交给了数据库，而操作事务1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务2添加，就好像产生了幻觉一样。 不可重复读和脏读的区别脏读是某一事务读取另一个事务未提交的脏数据不可重复读是读取了前一事务提交的数据 幻读和不可重复读都是读取了另一条已经提交的事务，不同的是：不可重复读查询的是同一个数据项。而幻读针对的是一批数据。 InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）处理幻读的问题。 MVVCMVVC，即多版本并发控制（Multiversion Concurrency Control）MVVC的实现是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的，不同存储引擎的MVVC实现是不同的，典型的有乐观并发控制和悲观并发控制。 InnoDB的MVVC，是通过每行记录后面保存两个隐藏的列来实现的，这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间），当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。 MVVC只在Repeatable Read和Read Committed两个隔离级别下工作，其他两个隔离级别都和MVVC不兼容，因为Read Uncommitted总是读取最新的数据行，而不是符合当前事务版本的数据行，而Serializable则会对所有读取的行都加锁。]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式一致性]]></title>
    <url>%2F2018%2F03%2F08%2F%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%2F</url>
    <content type="text"><![CDATA[之前面试时被问过，如果数据备份在两台机器A和B，修改数据库如何保证两个备份数据的一致：另设一个协调者节点C，客户端对数据的修改先是将命令发往C。C向A、B发出提交事务请求（说明，这里用的是2PC协议，即Two-phase-commit，二阶段提交协议）A和B完成事务的提交后向协调者C发送ACK消息yes，协调者接收到所有参与者反馈的Ack消息后完成事务。假设任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的响应，那么会中断事务。]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper学习]]></title>
    <url>%2F2018%2F03%2F08%2Fzookeeper-study%2F</url>
    <content type="text"><![CDATA[zookeeper是一个典型的发布/订阅模式的分布式数据管理与协调框架，开发人员可以用它来进行分布式数据的发布和订阅，另一方面，通过zookeepre中丰富的节点类型进行交叉使用，配合watcher事件通知机制，可以非常方便地构建一系列分布式应用中都会涉及的核心功能，如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master选举，分布式锁和分布式队列等。 zookeeper是Google Chubby的开源实现，zookeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口给用户使用。 zk将全量数据存储在内存中，以此来实现提交服务器吞吐，减少延迟的目的。zk用来进行分布式环境的协调。zk引入了Leader、Follower和Observer三种角色。zk集群中所有机器通过一个Leader选举过程来选定一台被称为Leader的机器，Leader服务器为客户端提供读和写服务，除Leader外，其他机器包括Follower和Observer，Follower和Observer都能够提供读服务，唯一区别在于Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。zk允许用户在指定节点上注册一些watcher(事件监听器)，并且在一些特定事件触发时，zk服务端将事件通知到感兴趣的客户端上去，该机制是zk实现分布式协调服务的重要特性。zk已经得到了广泛的应用，诸如hadoop、Hbase、Storm和Solr等越来越多的大型分布式项目都已经将zk作为其核心组件。 在Dubbo的实现中，对注册中心模块抽象封装，因此可以基于其提供的外部接口来实现各种不同类型的注册中心，例如数据库，zookeeper和Redis等。zk是一个树形结构的目录服务，支持变更推送，因此非常适合作为Dubbo服务的注册中心。 节点ZNode是zk中数据的最小单元，每个ZNode上都可以保存数据，同时还可以挂载子节点，因而构成了一个层次化的命名空间，我们称之为树。zk中有四种节点类型：1.持久节点：persistent创建后一直存在zk服务器上，直到有删除操作来主动清除这个节点。2.持久顺序节点：persistent-sequential在zk中，每个父节点会为它的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。3.临时节点：Ephemeral临时节点的生命周期和客户端的会话绑定到一起，如果客户端会话失效，那么这个节点会自动清理。zk规定了不能基于临时节点来创建节点，即临时节点只能作为叶子节点。4.临时顺序节点：Ephemeral_sequential 事务在zk中，事务是指能够改变zk服务器状态的操作，我们称之为事务操作或更新操作，一般包括数据节点的创建和删除、数据节点内容更新和客户端会话创建与失效等操作。每一个事务请求，zk都会为其分配一个全局唯一的事务ID，用ZXID表示，通常是一个64位的数字。每个ZXID对应了一次更新操作，从这些ZXID中可以间接识别出zk处理这些更新操作请求的全局顺序。 分布式锁如果不同的系统或是同一系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性。在这种情况下，就需要使用分布式锁了。X锁和S锁的根本区别在于，加X锁后，数据对象只对一个事务可见，而加S锁后，数据对所有事务都可见。 排他锁（X锁）zk上用一个数据节点来表示一个锁，例如 /exclusive_lock/lock 节点就可以定义为一个锁。在需要获取排他锁时，所有客户端都会通过调用create()方法，在 /exclusive_lock 节点下创建临时子节点 /exclusive_lock/lock，zk会保证在所有的客户端中最终只有一个客户端能创建成功，那么就可以认为该客户端获取到了锁。同时，所有没有获取到锁的客户端就需要到 /exclusive_lock 节点上注册一个子节点变更的 watcher 监听，以便实时监听到 lock 节点的变更情况。释放锁，有两种情形： 当前获取到锁的客户端机器宕机，那个zk上这个临时节点就会被移除。 正常执行完业务逻辑后，客户端就会主动将自己创建的临时节点删除。 之前获取到锁的客户端释放锁后，zk会通知所有在 /exclusive_lock 节点上注册了子节点变更 watcher 监听的客户端，这些客户端在接到到通知后，再次重新发起分布式锁的获取，即重复“获取锁”过程。 共享锁（S锁）用一个临时顺序子节点表示一个共享锁，例如“/shared_lock/[Hostname]-请求类型-序号”。 参考 从Paxos到Zookeeper分布式一致性原理与实践，倪超，出版时间：2015-02-01]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[女生节二维码]]></title>
    <url>%2F2018%2F03%2F07%2F%E5%A5%B3%E7%94%9F%E8%8A%82%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[3.7号女生节，网上一些学校拉了些祝福标语，微博上看到了个视频，里面各种祝福语，然后，一个二维码一闪而过。我机智地截了个图发到自己微信上，然后识别二维码，打开了一个页面：挺有创意的啊，怎么做的，我在浏览器端打开看了下网址： https://morestory.github.io/morestory/ 原来是用的github，源码这么简单，假设账户名为AA，在B目录下建一个index.md，然后把静态页面逻辑写在这个index.md中。然后访问 AA.github.io/B 这么简单就能看到渲染后的H5页面，我试验了一下失败了。看了下morestory的这个仓库，有另一个分支，里面提到jekyll，难道是用到了jekyll？有待研究。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java秒杀系统方案优化 高性能高并发实战》学习笔记]]></title>
    <url>%2F2018%2F03%2F07%2Ftodo-miao_sha%2F</url>
    <content type="text"><![CDATA[spring-boot这个项目是基于spring-boot来做的，教了如何打包成jar包和war包，spring-boot内置了tomcat，一个spring-boot项目运行起来非常方便。 数据校验JSR-303是一个数据验证的规范，引入依赖spring-boot-starter-validation，就可以在后台做各种数据校验，还可以自定义验证器。项目中定义了一个验证器IsMobile，验证是不是一个合法的手机号。 封装这个项目中一些代码的封装方法值得学习，用类com.imooc.miaosha.result.Result统一封装json接口数据。异常类com.imooc.miaosha.exception.GlobalException 和 com.imooc.miaosha.exception.GlobalExceptionHandler 统一处理各种异常情形，从而接口总是能返回json串。统一异常处理可以参考：Controller层方法，进行统一异常处理有两种解决方案：通知控制器@ControllerAdvice或者使用AOP。项目中用的是通知控制器。项目中GlobalExceptionHandler类定义了异常处理逻辑，对类加了注解： 123@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123;&#125; 很多博客里说用@RestControllerAdvice注解，这样就可以不用加@ResponseBody了。@RestControllerAdvice和@ControllerAdvice的区别见： Annotation Type RestControllerAdvice @RestControllerAdvice vs @ControllerAdvice @RestControllerAdvice： A convenience annotation that is itself annotated with @ControllerAdvice and @ResponseBody. redis见识了redis的强大之处，项目里封装了一个用redis存取对象的方法，先用com.alibaba.fastjson.JSON将对象序列化成json字符串，然后将json字符串存在redis中。redis缓存可以设置过期时间，利用这一特性，项目中有多处应用：图片验证码可以用redis缓存，一定时间后失效；用户登录session可以保存在redis中，一段时间后失效；接口限流防刷，例如一个用户1分钟内对同一个接口的请求不能超过100次。项目中讲了很多页面优化的方法，其中很多方法是用到了redis，例如页面缓存，对象缓存等。 分布式session将登录用户的信息保存在redis中，实现分布式session。用户登录时，生成一个uuid，作为redis的key，value是用户信息，并且将这个key放在cookie中，然后response.addCookie(cookie)，把cookie返回给浏览器。拦截器中，在控制器请求处理前，会从redis中取到用户信息，key从哪里来的呢，一个http请求会在cookie或者请求参数中带上前面的key。 JMeter使用JMeter进行压测 消息队列之前学过activemq，这里又学习了一下rabbitmq。秒杀操作的逻辑是先在redis中预减库存，然后再去操作数据库。为了减轻redis的压力，用本地HashMap保存了可秒杀商品的剩余数量，相当于对库存做了个内存标记。操作数据库也是不是直接同步去访问，而是使用了消息列队异步访问，把一条秒杀请求放入消息队列，然后再慢慢处理。rabbitmq有四种交换机模式：Direct模式、Topic模式、Fanout模式、Header模式。项目中用的是最简单的Direct模式。 拦截器拦截器 com.imooc.miaosha.access.AccessInterceptor，接口方法真正的业务逻辑之前常有些共同的逻辑，比如判断用户是否登录，以及对接口的限流防刷控制，可以一并放在拦截器中。项目用的是spring-boot，不用写各种xml配置文件了，拦截器在类com.imooc.miaosha.config.WebConfig中进行注册。 12@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter&#123;&#125; 如果在处理接口跨域问题，也是在这个类中进行配置，类WebMvcConfigurerAdapter中有抽象方法public void addCorsMappings(CorsRegistry registry) {}，实现一下就可以了。 静态分离java web项目中前端页面的展示，以及用得比较多的是返回一个jsp，后台控制器方法绑定参数，把jsp渲染好后返回给前台。现在主流的做法是，前端用纯html编写，后台返回json串，前台用异步请求到json格式的接口数据，然后填充到html中。这就是静态分离。 此外还有关于加盐加密、图形验证码等知识。 秒杀流程 秒杀活动开始之前有个活动倒计时，时间到了则会放开秒杀的权限，并生成一个验证码展示在前面页面，并把验证结果存在redis中，这里利用redis有过期时间的特性，也给验证码的缓存加了个过期时间。这里的redis缓存用的是redis的string类型。 在秒杀之前先要填一个验证码verifyCode，点击秒杀按钮时，先发送ajax请求到后台获取真实的秒杀地址path，这里秒杀地址是隐藏的，目的是防止有人恶意刷秒杀接口。所谓隐藏地址，其实是在请求地址中加一段随机字符串，这段字符串是变化的，因此秒杀请求地址是动态的； 先说下如何获取真实的秒杀地址，后台先访问redis，验证一下这个验证码有没有过期以及这个verifyCode是不是正确，验证码验证通过后，先删除这个验证码缓存，然后生成真实地址； 真实地址随机字符串由uuid以及md5加密生成，并且保存在redis中，并且设置了有效期； 从浏览器端向秒杀地址发起请求，带上path参数去后台调用真正的秒杀接口，下面是秒杀接口的逻辑； 访问redis，验证path有没有过期，以及是不是正确。这里验证path以及上面的校验验证码，都是用userId对应生成的一个key值去取redis中的数据； path验证通过后，先访问内存标识，看秒杀的这个商品有没有卖完。每一种参与秒杀活动的商品都在内存里用HashMap设置了一个标识，标识某个商品id商品是否卖完了。这里的是否卖完的内存标识设置以及每种参与秒杀商品的库存存入redis是在系统启动时做的； 如果内存标识中这个商品没有卖完，则要看这个用户在这次活动中是否已经秒杀到过这种商品，因为我们的秒杀规则是一个用户id对于某个商品id的商品只能秒杀一件。如何判断该用户有没有秒杀过这件商品呢，秒杀记录也保存在redis缓存中； 如果判断秒杀过则返回提示，如果没有秒杀过，继续； 上面说过系统加载时redis中保存了各商品对应的库存，这里用到redis的原子操作的方法decr，将对应商品的库存减1，此时数据库时的库存还没有减，因此是预减库存； desc方法返回该商品此时的库存，如果小于0，说明商品已经卖完了，此次秒杀无效，并且设置该商品的内存标识为true，表示已卖完； 正确地预减库存后，然后就要真正操作数据库了，数据库一般是性能瓶颈，比较耗时，因此决定用异步方式处理。对于每一条秒杀请求存入消息队列RabbitMQ中，消息体中要包含哪个用户秒杀哪个商品的信息，这里是封装了一个消息体类，这样一个秒杀请求就进入了消息队列，一个秒杀请求还没有完成，真正的秒杀请求的完成得要持久化到数据库，生成订单，减了数据库的库存才能算数，这时在客户端显示的一般是排队中，比如以前在抢购小米手机时，我就看到这样的展示，过一会再刷新页面就显示没抢到； 消息队列处理秒杀请求。先从消息体中解析出用户id和商品id，查数据库看这个商品是否卖完了，查数据库看该用户对于这个商品是否有过秒杀记录； 数据库减库存，数据库生成订单，这两项持久化地写数据库操作放在同一个事务中，要么都执行成功，要么都失败。其中生成订单又是另外一个事务中，在这个生成订单事务中，会分别在订单表、秒杀订单表生成一条记录，并把秒杀记录对象，包括秒杀单号、订单号、用户id、商品id，存入redis中。如果数据库减库存失败，表明商品卖完了，则要在redis中设置该商品已卖完的标识。spring项目中使用事务，只用在相应的方法前面加个注解@Transactional，那么这个方法里的操作都在一个事务里了； ajax发起秒杀请求，秒杀请求的处理逻辑最后也只是把这条请求放入消息队列，并不能返回是否秒杀成功的结果。因此，当秒杀请求正确响应后，即请求放入消息队列后，需要另外一个请求去轮询秒杀结果，秒杀成功的标志是生成秒杀订单，并把秒杀订单对象放入redis中。所以轮询秒杀结果，只用去轮询redis中是否有对应于该用户的该商品的秒杀订单对象，如果有，则表明秒杀成功，并在前台给出提示。 上面的秒杀流程对应的流程图如下：步骤1到12，主体是redis预减库存，生成消息队列： 步骤13到14是处理消息队列： 步骤15，是客户端请求秒杀结果： 秒杀场景是从客户端的ajax请求发起的，上面15个步骤可以用下面的js串起来： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//秒杀按钮触发下面的js方法function getMiaoshaPath()&#123; var goodsId = $("#goodsId").val(); g_showLoading(); $.ajax(&#123; url:"/miaosha/path", type:"GET", data:&#123; goodsId:goodsId, verifyCode:$("#verifyCode").val() &#125;, success:function(data)&#123; if(data.code == 0)&#123; var path = data.data; //获取到秒杀地址后，发起秒杀请求 doMiaosha(path); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125;//发起秒杀请求function doMiaosha(path)&#123; $.ajax(&#123; url:"/miaosha/"+path+"/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val() &#125;, success:function(data)&#123; if(data.code == 0)&#123; //获取秒杀结果 getMiaoshaResult($("#goodsId").val()); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;); &#125;//获取秒杀结果function getMiaoshaResult(goodsId)&#123; g_showLoading(); $.ajax(&#123; url:"/miaosha/result", type:"GET", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; var result = data.data; if(result &lt; 0)&#123; layer.msg("对不起，秒杀失败"); &#125;else if(result == 0)&#123;//继续轮询 setTimeout(function()&#123; getMiaoshaResult(goodsId); &#125;, 200); &#125;else&#123; layer.confirm("恭喜你，秒杀成功！查看订单？", &#123;btn:["确定","取消"]&#125;, function()&#123; window.location.href="/order_detail.htm?orderId="+result; &#125;, function()&#123; layer.closeAll(); &#125;); &#125; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 内存标记的分布式一致性上面采用内存标记的方式，本地hashmap变量，如果分布式场景，多份内存标记，如何实现分布式一致性？两种常用办法： 所有的进程去访问一个共享内存，这个共享内存是虚拟的。 每一个机器都有一个存储内容的本地副本，读取操作我们可以从本地内存进行读取，写入操作我们可以现在本地下入之后，再通过广播向其他的内存块发送update消息。 参考 Java秒杀系统方案优化 高性能高并发实战]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发中的优化技术]]></title>
    <url>%2F2018%2F03%2F05%2Fweb-optimize%2F</url>
    <content type="text"><![CDATA[高并发的网页应用中，每秒内查询次数QPS(Query Per Second)是个很重要的性能指标。数据库查询是代码层面的性能瓶颈，此外还有http连接也会产生性能开销。提高服务器性能的一个重要技术就是用缓存。浏览器缓存，CDN缓存，页面缓存，对象缓存等，其中redis是实现页面缓存和对象缓存的常用方法。浏览器缓存一般结合web开发中的静态分离技术。 用jsp还是html？jsp中填充数据是同步加载，因此页面响应有时会很慢。第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高。静态分离后，页面用纯html编写，异步请求服务器的数据，然后填充到页面。 使用jsp是在服务端把视图渲染好后再返回给浏览器，用户发送一个http请求，请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。这种方式的mvc交互过程如下图： 使用静态分离后，从浏览器发送AJAX请求，然后服务端接受该请求并返回JSON数据返回给浏览器，最后在浏览器中进行界面渲染。这种方式的mvc交互过程如下图：上图的MVC模式简化为以下前后端分离模式： 跨域问题见参考2，参考1中也有提及。 参考 从MVC到前后端分离 服务器端解决跨域问题的三种方法]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis&memcache学习]]></title>
    <url>%2F2018%2F03%2F01%2Fredis%26memcache%2F</url>
    <content type="text"><![CDATA[redisredis和memcache是两种流行的分布式缓存框架。redis-benchmark工具可以做压测 redis做缓存，可以有页面缓存，对象级缓存。对象级缓存，如果数据对象有更新，比如修改了用户密码，则要把缓存更新掉，否则会出现数据不一致。 redis-cliredis客户端 redis-cli //清空 redis缓存 flushdb redis缓存可以设置一个有效期，利用这个特性，redis可应用于很多场景：图片验证码可以用redis缓存，一定时间后失效；用户登录session可以保存在redis中，一定时间后失效；接口限流防刷，例如一个用户1分钟内对同一个接口的请求不能超过100次，可以将某用户对某接口的访问次数存在redis中，每访问一次value加1。 redis的优势 性能极高Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 原子Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。Redis的操作之所以是原子性的，是因为Redis是单线程的。 丰富的特性Redis还支持 publish/subscribe, 通知, key 过期等等特性。 redis的单线程架构Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。 区别 redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。memcache不支持数据的持久化。例如，redis客户端 redis-cli，执行 shutdown save，关闭redis服务，在下次重新启动redis服务后，上次保存的内存还能找得到。 进程线程模型 单进程单线程模型：redis 多进程单线程模型：Nginx 单进程多线程模型：Memcached 参考 谈谈redis,memcache的区别和具体应用场景 Redis单线程架构]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习oauth2.0]]></title>
    <url>%2F2018%2F02%2F07%2Foauth2.0-study%2F</url>
    <content type="text"><![CDATA[最喜欢参考3 的表述。参考3 最后给了个github项目地址，可惜博主后来删了这个仓库，我在其他用户的仓库里看到这个项目，于是folk到我的仓库了，见参考4，用springBoot写了两个子项目分别模拟豆瓣和QQ，运行main函数即可启动springBoot。 参考 第十七章 OAuth2集成——《跟我学Shiro》 理解OAuth 2.0 一张图搞定OAuth2.0 dataU-OAuth oauth原理简述 帮你深入理解OAuth2.0协议 授权机制说明-微博API API-微博API]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git公钥配置]]></title>
    <url>%2F2018%2F02%2F04%2Fgit_%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[无论是 github，还是码云，我们要clone一个工程时，会有两个地址供选择，HTTPS和SSH，有什么区别呢？ 公钥有两种，部署公钥和个人公钥：配置了部署公钥，只支持只读操作；如果想要对仓库进行写操作，请添加个人公钥。 似乎个人公钥是针对整个机器而言的，我在码云上添加了我的某个阿里云服务器的个人公钥，然后就可以在我的那个阿里云服务器上任意clone(也可以其他操作？)我的码云上的仓库了，当然这要求是使用SSH地址，如果使用HTTPS地址来clone的话，则要求输入码云的用户名密码，挺麻烦的，我猜想啊，如果我在码云的某个仓库A配置了我的阿里云服务器的部署公钥，估计用HTTPS也可以免密了，什么原理呢，有待学习。 我在git bash中要把本地仓库关联一个远程仓库，开始时使用远程仓库的SSH地址，然后报错了，提示权限问题：关联远程仓库的HTTPS地址就没报错。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习AQS-AbstractQueuedSynchronizer]]></title>
    <url>%2F2018%2F02%2F01%2FAbstractQueuedSynchronizer%2F</url>
    <content type="text"><![CDATA[AQS是java.util.concurrent的核心组件之一，它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。AQS的功能可以分为两类：独占功能和共享功能。AQS有很多子类，不同子类，不同的同步机制和阻塞机制，释放锁和加锁的逻辑可能不一样，AQS只是提供了一种基于FIFO队列、可以用于构建锁或者其他相关同步装置的基础框架。 看源码，ReentrantLock、CountDownLatch、Semaphore、FutureTask、ThreadPoolExecutor，都有个名叫Sync的静态内部类，继承自AQS。 test 参考 《Java并发编程从入门到精通》，张振华，清华大学出版社，2015年7月第一版]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程中的sleep方法和wait方法]]></title>
    <url>%2F2018%2F02%2F01%2Fsleep%26wait%2F</url>
    <content type="text"><![CDATA[sleep和wait都会释放CPU的执行权，区别是sleep不释放锁，wait释放锁。 参考 《Java并发编程从入门到精通》，张振华，清华大学出版社，2015年7月第一版]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习UML类图]]></title>
    <url>%2F2018%2F02%2F01%2Fuml-study%2F</url>
    <content type="text"><![CDATA[UML类图，类之间的几种主要关系： 几种关系的强弱比较：组合&gt;聚合&gt;关联&gt;依赖 组合大雁与大雁的翅膀的关系是组合关系，contains-a： 聚合雁群与大雁的关系是聚合关系，has-a： 关联强关联关系。被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类B的全局变量。 依赖类A的方法中用到类B，类B作为参数被A的某个方法中使用，这种关系是偶然的，临时的，非常弱的。]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java开发中的并发]]></title>
    <url>%2F2018%2F02%2F01%2Fconcurrent-study%2F</url>
    <content type="text"><![CDATA[彩票app有个排行榜，显示中奖率，后台程序一个线程取购彩记录，计算中奖率时，可能此刻另一个线程在更新中奖率。所以对中奖率的操作需要是线程安全的。 白名单/黑名单。黑名单可以使用 java.util.concurrent.CopyOnWriteArraySet。CopyOnWrite 并发容器即写时复制的容器，适用于读多写少的场景。在往容器中添加元素的时候，不是直接往容器中添加，而是将当前容器进行 Copy，复制出一个新的容器，然后往新的容器里添加元素，添加完之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发地读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。CopyOnWrite 有数据一致性问题。CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的数据马上能读到，请不要使用 CopyOnWrite 容器。 几个好的资源阿里在nignx的基础上进行改进并开源的服务器 tengine阿里有开源的中间件 mycat，数据库分库分表需求时可以考虑下。 java内存模型Java Memory Model (JAVA 内存模型）描述线程之间如何通过内存(memory)来进行交互。 具体说来， JVM中存在一个主存区（Main Memory或Java Heap Memory），对于所有线程进行共享，而每个线程又有自己的工作内存（Working Memory），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作并非发生在主存区，而是发生在工作内存中，而线程之间是不能直接相互访问，变量在程序中的传递，是依赖主存来完成的。对JMM的介绍，参考3和参考4的文章写得很好，一下子把JMM和JVM的关系讲清楚了。参考3中对内存交互操作：Lock(锁定)/Read(读取)/Load(加载)/Use(使用)/Assign(赋值)/Store(存储)/Write(写入)/Unlock(解锁)，做了精辟地总结，让人印象深刻。简单地讲，JVM的垃圾回收器处理的是堆区的内存，这里的堆区包括共享堆和方法区，这个堆区就对应了JMM中的主存区，为所有线程共享。JVM中的栈区就对应了JMM中每个线程自己的工作内存。 volatile保证了线程可以正确地读取其他线程写入的值。volatile只提供了内存可见性，而没有提供原子性。synchronized作为一种同步手段，解决java多线程的执行有序性和内存可见性。 原子操作：atomicjava.util.concurrent.atomic包里，有一批原子处理类，主要用于在高并发环境下的高效程序处理，这些处理类包括：AtomicInteger、AtomicLong等。原子操作atomic的实现原理，是利用CPU的比较并交换（即CAS）和非阻塞算法。如果查看AtomicInteger的源码，会发现有些是通过调用JNI的代码实现的。JNI（Java Native Interface）为Java本地调用，允许java调用其他语言。而CAS（compareAndSwapInt）就是借助C来调用CPU底层指令实现的。 Fork/Join框架Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork就是把一个大任务切分成若干个子任务并行地执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。 参考 深入理解Java内存模型（一）——基础 《Java并发编程从入门到精通》，张振华，清华大学出版社，2015年7月第一版 jvm主内存与工作内存，内存模型反映的java多线程问题 浅析jvm与jmm模型结构与关系]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm内存管理]]></title>
    <url>%2F2018%2F02%2F01%2Fjvm-study%2F</url>
    <content type="text"><![CDATA[jvm以分代的模式对内存进行管理。 永久代方法区属于永久代。方法区在放装载的类数据信息，包括运行时常量池、字段信息、方法信息、静态变量。 jvm 参数-Xss 每个线程的栈的大小-Xms 初始堆大小-Xmx 最大堆大小-Xmn 新生代的堆大小 -XX:PermSize 设定内存的永久区的初始大小-XX:MaxPermSize 永久区的最大值-XX:NewSize 新生代的初始大小-XX:MaxNewSize 新生代的最大值-XX:NewRatio 年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）-XX:SurvivorRatio Eden和Survivor区的大小比值 jvm分析工具jstatjstat命令可以查看堆内存各部分的使用量,以及加载类的数量。 jstat -gc pid 上面命令可以显示gc的信息，查看gc的次数及时间。其中最后五项，分别是 young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。 jstackjstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码下面来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息先用 ps -ef|grep ‘xxx’比如得到进程ID为21711第二步，找出该进程内最耗CPU的线程用 top -Hp pid找到cpu最耗时的线程pid为2174221742对应的16进制是54eeprintf “%x\n” 21742，即可将十进制转化为十六进制数。然后jstack上场了，它用来输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep， jstack 21711 | grep 54ee 这样就打印出了最耗时线程的堆栈信息。 参考 JVM调优之jstack找出最耗cpu的线程并定位代码]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java标记接口]]></title>
    <url>%2F2018%2F02%2F01%2Fjava%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Java中常用的三个标记接口分别是:RandomAccess、Cloneable、Serializable。标记接口的一个显著标志是没有任何方法。当某个类实现某个标记接口的时候,我们就认为这个类拥有了接口标记的某种功能。考虑接口 Cloneable，它的作用是标记该对象是否拥有克隆的能力，但是，java.lang.Object类中本身已经有了一个方法： protected native Object clone() throws CloneNotSupportedException 按道理来说的话每一个类都应该可以运行clone方法才对呀，为什么还需要这样一个标记接口呢？接口就是用来标记某个类拥有了哪些功能、特性，而标记接口则是在面向对象的角度来看，更高级的一种抽象：即使你拥有这个方法也不行，因为你没有这个功能的标记接口，所以在调用clone方法的过程中，如果对象没有实现Cloneable接口，那么虚拟机就会抛出一个CloneNotSupportedException异常。 参考 内功心法 – Java标记接口]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络传输中的密码学]]></title>
    <url>%2F2018%2F01%2F30%2Fencryption-start%2F</url>
    <content type="text"><![CDATA[api用于服务器端和客户端之间通信。有些数据比较敏感，在设计api时需要进行加密处理。 例如，用户登录密码，服务器上是不会明文存储用户登录密码的，一种做法是，对明文密码加盐后进行md5加密，得到的字符串存到用户表的密码字段。 有些数据在传输过程中，不能明文传输，比如，有些应用中可以用电话卡来充值自己的账户，这样app客户端就会把卡号和密码传给服务器。如果这个包被截获了，就能随意使用这个电话卡。因此，卡号和密码在传输前，在客户端就要进行加密，在服务器端解密传过来的数据，然后验证这个卡号和密码的有效性，完成充值过程。 有些服务是付费的，比如彩票投注接口，帮下游出票，然后收取佣金，下游发来投注请求，要不要出票呢。这里会先验证发送者的身份，要求发送方做数字签名，并将签名带在请求中传到服务器，服务器验证签名，确认请求用户的合法性。 由上可知，一个前后端分离的系统，后端为前端提供数据时，不仅仅是简单地通过http协议将前端需要的数据以json格式传过去就行了，还要考虑很多安全问题，根本原因是，我们的传输介质是不可靠的。因此网络上如何安全地进行数据传输是个好课题。 对称加密发送方和接收方用同一个密钥进行加密解密。优点，速度快常见的对称加密算法有：DES（Data Encryption Standard） 非对称加密该加密方式规定了密钥需要有一对儿，一个公钥（Public Key)和 一个私钥（Private Key/Security Key),如果用公钥加密信息，就需要用相同配对的私钥才能解密，反之亦然。通信双方用非对称加密进行通信，怎么取得对方的公钥呢？双方需要一个可靠的机构或者是第三方个人来担保获得的公钥是正规途径得来的。非对称加密也叫做公开密钥加密，公钥是公开的，私钥是非公开的，其实使用非对称加密，只能保证单向数据传输的安全性。优点：数据可靠性相当强，很大程度上保证了身份认证。非对称加密算法有：RSA、D-H、Elgamal 非对称加密的一个很严重的缺点，是数据传输仅单向安全。服务器将用户的隐私数据用私钥加密后，传给客户端。客户端用公钥解密，得到自己的隐私数据。但是，服务器端用私钥加密传输到客户端的过程中，如果被第三方截获了，因为公钥是公开的，第三方用公钥解密，就得到了用户的隐私数据。因此，有公钥的客户端向服务器传数据是安全的，就算被被三方截获了，由于第三方没有私钥，所以第三方也不知道数据是真实内容。而有私钥的服务端向有公钥的客户端进行数据传输就不是安全的。 https上面的对称加密，非对称加密，只有当消息在信道传输时没有被别人破坏，也就是中间人攻击，才能发挥作用。防止中间人攻击的解决办法是https。https通信的过程结合了对称加密，非对称加密。上面已经阐述，对称加密传输速度快，我们希望最理想的情况，用对称加密通信，实际上，为了获取加密效率和安全性的平衡，最终也的确是进行对称加密通信，非对称加密作为破解难度更大的加密方式，一般也只用作某个对称加密算法的密钥传递信道。下面来一步步解决安全问题。 客户端 C 生成一个自己的对称密钥 P1，要是能把 P1 安全地告诉服务器 S，然后 C 和 S 就能用对称加密算法进行安全通信了。但是 C 怎么把 P1 安全地告诉 S 呢？ 上面说了非对称加密是单向安全的，假设 S 生成一对非对称密钥，公钥 Public-S 和私钥 Private-S，如果客户端 C 有公钥 Public-S，那么 C 把自己的对称密钥 P1 用 Public-S 加密后传给服务器就是一个安全的过程。但是客户端 C 如何获取到服务器 S 的公钥 Public-S 呢，谁能保证这个 Public-S 是真的呢？因为这里有这么样一个风险，如果有中间人攻击，有个坏人用自己的服务器 S2 生成一对非对称密钥，公钥 Public-S2 和私钥 Private-S2，假设这个坏人把客户端 C 上的公钥换成自己的公钥 Public-S2 ，然后用自己的私钥来与客户端进行通信，客户端不能发觉。所以需要有人告诉 C，公钥 Public-S 是 S 的，其他的公钥都是假的。 有个权威机构做公证人，这个公证人就是 CA，服务器 S 向 CA 提交了申请，CA 审核通过后，将证书颁发给 S ，客户端 C 访问服务器 S 的时候，S 将证书给到 C，C 从证书中拿到 S 的非对称加密的公钥 Public-S。 这就相当于 S 向 C 出示了自己的身份证，这真的是我。 CA发给 S 的证书是如何保证 Public-S 真的是 S 的公钥呢？CA 也有自己的一套非对称加密密钥，公钥 Public-CA 和私钥 Private-CA，CA用自己的私钥，对 S 的公钥和一些相关信息一起加密，这就是”数字证书”（Digital Certificate）。上面提到“C 从证书中拿到 S 的非对称加密的公钥 Public-S”，具体呢，C 用CA的公钥 Public-CA ，解开数字证书，得到 S 的公钥 Public-S，只要 CA 的公钥是真实的，S 的公钥就一定是真实的。 问题还在，作为客户端 C，你怎么确信 CA 的公钥 Public-CA 是真实的呢，上面引出CA的初衷是防止有些坏人伪造服务器 S 的公钥。但是如果有人伪造CA的公钥怎么办，似乎用非对称加密链来保证公钥的真实性是一个鸡生蛋，蛋生鸡，无穷无尽的问题。答案是，浏览器或操作系统，出厂自带最顶层的 CA 的公钥。 为什么就不能怀疑操作系统、浏览器？假设你的电脑是windows10操作系统，用的是chrome浏览器，要是微软，谷歌有心做恶，在证书上做手脚。那就没有办法了。所以，综上，SSL 协议采用的CA证书都只是相对安全的，没有绝对的安全。国家得要研制自己的操作系统，自己的浏览器，这样才能保证国家的网络安全。 下面考虑一个场景，张三给李四写信，上面讨论的 1 到 6 步，是考虑身份认证的问题，大致能使张三和李四彼此确认身份。还有个问题，李四收到张三的信后，如果保证信件内容没有修改呢，张三在信件末尾附上数字签名即可。 这个数字签名怎么来的呢？张三写完信后，对信件内容用 hash函数，生成信件摘要，然后张三用自己的私钥对摘要加密，生成数字签名（signature）。张三在信件末尾附上数字签名。 李四收到信后，取下数字签名，用张三的公钥解密，得到信件的摘要1。然后对信件内容用 hash函数，也得到一个摘要2，如果摘要1和摘要2是一样的，就说明这封信未被修改过。 下面来用Charles看看，用https来传数据是不是真的安全，先安利一个提供API服务的公司 易源数据 ，先说句题外化，有了这些专门提供数据接口的公司，我认为很多app应用的后端开发可以不用请专门的后台的开发工程师了，突然又多了一丝危机感。易源数据的数据接口支持http和https两种形式，下面是分为用 http 和 https 两种方式请求QQ音乐接口，搜索关键词“我”的歌曲列表，然后用Charles截包，试试能不能看到传输的数据，首先，两种方式在浏览器端返回的数据都是一样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; "showapi_res_code": 0, "showapi_res_error": "", "showapi_res_body": &#123; "ret_code": 0, "pagebean": &#123; "w": "我", "allPages": 14, "ret_code": 0, "contentlist": [ &#123; "m4a": "http://ws.stream.qqmusic.qq.com/5516807.m4a?fromtag=46", "media_mid": "0004caJA35Oeuo", "songid": 5516807, "singerid": 65319, "albumname": "我", "downUrl": "http://dl.stream.qqmusic.qq.com/5516807.m4a?vkey=34B7AD5C9175C712C73FB6C75DD32B073D2B6F5B63BB7B9C99DDE4AA4597CA0143578A988DB6DF5333FF5BFA6B84E6B765B56E4E2DFAF140&amp;guid=2718671044", "singername": "魏语诺", "songname": "我", "strMediaMid": "0004caJA35Oeuo", "albummid": "004d8lSi2SADaf", "songmid": "0004caJA35Oeuo", "albumpic_big": "http://i.gtimg.cn/music/photo/mid_album_300/a/f/004d8lSi2SADaf.jpg", "albumpic_small": "http://i.gtimg.cn/music/photo/mid_album_90/a/f/004d8lSi2SADaf.jpg", "albumid": 491426 &#125;, &#123; "m4a": "http://ws.stream.qqmusic.qq.com/203108192.m4a?fromtag=46", "media_mid": "002wFoJ62fqw0u", "songid": 203108192, "singerid": 22820, "albumname": "我", "downUrl": "http://dl.stream.qqmusic.qq.com/203108192.m4a?vkey=34B7AD5C9175C712C73FB6C75DD32B073D2B6F5B63BB7B9C99DDE4AA4597CA0143578A988DB6DF5333FF5BFA6B84E6B765B56E4E2DFAF140&amp;guid=2718671044", "singername": "海龟先生", "songname": "我", "strMediaMid": "002wFoJ62fqw0u", "albummid": "000V1wYm2jw606", "songmid": "002wFoJ62fqw0u", "albumpic_big": "http://i.gtimg.cn/music/photo/mid_album_300/0/6/000V1wYm2jw606.jpg", "albumpic_small": "http://i.gtimg.cn/music/photo/mid_album_90/0/6/000V1wYm2jw606.jpg", "albumid": 2149730 &#125; ], "currentPage": 1, "notice": "", "allNum": 400, "maxResult": 30 &#125; &#125;&#125; http请求http://route.showapi.com/213-1?showapi_appid={appid}&amp;showapi_sign={sign}&amp;keyword=我 这里我们看到，不管是请求的参数，还是返回的结果，都是明文可见的。 https请求http://route.showapi.com/213-1?showapi_appid={appid}&amp;showapi_sign={sign}&amp;keyword=我 这里我们看到，不管是请求的参数，还是返回的结果，都有一堆乱码。 chrome 与 https前些天（2018-2-9），看到一则新闻，新Chrome将标记非HTTPS网站为不安全，天呐，”这是谷歌为推动更多网络管理员采用HTTPS加密而采取的最新升级措施，这种加密协议意味着任何从用户电脑或设备发送到网站的数据都可安全传输，而不会被黑客截获。另外，HTTPS加密还可确保黑客无法对内容进行修改。”我相信，google的此举会大力推动https的流行。然后我在chrome中看了看新华网：当前我的chrome版本是64，据悉今年7月份发布chrome68，到时候，这个新华网估计会标示为“不安全”，到时候，估计一大堆网站蒙圈。我赶紧看了下360的极速浏览器：这个认证是啥，莫不是新华网给360交钱了？360的认证有公信力吗？印象中，好像上图这个“官网”字眼，也得网站所有方的人向百度交一笔钱的，真是，国人想赚钱，五花八门的方法多的是。 参考 网络传输的加密与解密 密码学笔记 数字签名是什么？ 怎么保证「CA 的公钥」是真实的？ 图解HTTPS 新Chrome将标记非HTTPS网站为不安全]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序学习]]></title>
    <url>%2F2018%2F01%2F29%2Fwe-app_study%2F</url>
    <content type="text"><![CDATA[一个小程序项目的目录结构： 文件类型一个小程序项目中的文件类型有以下几种： .json 后缀的 JSON 配置文件：小程序配置 app.jsonapp.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。 工具配置 project.config.json包括appid，调试基础库版本libVersion，项目设置里的设置项“ES6 转 ES5”、“上传代码时样式自动补全”等。 页面配置 page.json这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。 .wxml 后缀的 WXML 模板文件WXML 充当的就是类似 HTML 的角色，用来描述当前这个页面的结构。 .wxss 后缀的 WXSS 样式文件WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。 .js 后缀的 JS 脚本逻辑文件JS 脚本文件用来处理用户的操作。 体验小程序参考4，微信官方给了一个绝好的demo，根据这个demo可以学学小程序的常用组件和接口怎么用的，以及最终的效果展示。 基础库版本小程序的能力需要微信客户端来支撑，每一个基础库都只能在对应的客户端版本上运行，高版本的基础库无法兼容低版本的微信客户端。微信web开发者工具的“项目设置”可以设置“调试基础库”版本。 腾讯云支持按照参考5进行操作，腾讯云为开发者提供免费的开发环境和生产环境，按流程操作下来，跑通了。如果纯粹是跑跑样例程序来学小程序，这样做就行了唉，干啥还去买小程序解决方案呢！ 关于小程序的几个基础问题为什么小程序解决方案有会话管理服务器见参考9，因为小程序是CS模式的，和服务器的通讯是通过发送HTTP请求的方法来实现，没有session、cookie的概念，可以理解为传统C/S中客户端和服务器通讯。小程序和传统的WEB开发完全不同，没有会话也就是没有session功能，因此要用会话管理服务器专门处理。会话管理服务器，也叫鉴权服务器，专门用来处理微信登录鉴权信息。 2018-1-29 23:04:23新注册了一个微信小程序，对应了一个新的appId，在买腾讯云解决方案时，要填appId，因此新注册的小程序不能共用之前买的解决方案。 参考 微信小程序官方简易教程 微信小程序文件结构 微信小程序设计指南 体验小程序 微信小程序——腾讯云支持 生产环境部署 腾讯云-微信小程序-开发者工具方案-生产环境 wafer2-quickstart-nodejs 10分钟搭建微信小程序服务器 微信小程序精选Demo合集]]></content>
      <tags>
        <tag>we-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序demo学习_wafer-client-demo]]></title>
    <url>%2F2018%2F01%2F28%2Fwe-app_wafer-client-demo%2F</url>
    <content type="text"><![CDATA[买了腾讯云的微信小程序解决方案，按照参考1进行配置后，就把官方demo跑起来了，后台是wafer-cliet-demo，买来解决方案后，服务器里就带有这个demo的后台程序了，具体配置经过可以看我的另一篇文章《搭建微信小程序》。这个demo的github地址见参考2，今天来学学这个demo。 参考 资源初始化指引——微信小程序 wafer-client-demo_github]]></content>
      <tags>
        <tag>we-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[google与X比较]]></title>
    <url>%2F2018%2F01%2F27%2Fgoogle%26X%2F</url>
    <content type="text"><![CDATA[以图搜图网上看到一有趣的图片，恶搞本山老师： 然后我想上网搜搜相关的内容。分别用百度和google的以图搜图：这轮较量，百度胜。 翻译有一段话： These installations will also require maintenance shops and/or installers to have the ability/access to utilize approved configuration databases and tools for re-establishing the airworthiness of each new databus configuration. 14年10月，我要帮人翻译一段文字，里面有上面这么一句话。我用word2013自带的翻译，结果是： 这些设施也将需要维修店和（或）有能力/访问以利用已批准的配置数据库和工具，重新确立的每个新的数据总线配置适航的安装程序。 用google翻译的结果是： 这些设施也需要维修店和/或安装人员有能力/获得批准使用的配置数据库和工具，以便重新建立每一个新的数据总线配置的适航性。 后面半段，“以便重新建立每一个新的数据总线配置的适航性”比起微软的“重新确立的每个新的数据总线配置适航的安装程序”好太多了。 这轮较量，google胜。]]></content>
      <tags>
        <tag>fun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ps]]></title>
    <url>%2F2018%2F01%2F27%2Fps-study%2F</url>
    <content type="text"><![CDATA[技术无所谓高低，能解决问题就是好技术。ps是个好工具，看到一篇有趣的文章如参考1，看上去挺简单的，便快速尝试了一下。ps是一款强大的图片处理工具，也因为功能太强大了，学起来不是太容易，被诟病太复杂，这才有了美图秀秀等傻瓜式图片处理软件。 图层图层在ps中扮演着重要角色，对图像进行绘制或编辑时，所有的操作都是基于图层的。在ps中，打开的图像都有一个或多个图层。图层可以看作是一张独立的透明胶片，其中每一张胶片上都会绘制图像的一部分内容，将所有胶片按顺序叠加起来，便可以看到完整的图像。 参考 PS将蒙娜丽莎头像换成赵本山老师的脸]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习隐写术]]></title>
    <url>%2F2018%2F01%2F25%2Fsteganography-study%2F</url>
    <content type="text"><![CDATA[参考 隐写术总结 关于隐写术(Steganography)的简单总结]]></content>
      <tags>
        <tag>fun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学入门]]></title>
    <url>%2F2018%2F01%2F25%2Fstatistics-study%2F</url>
    <content type="text"><![CDATA[方差与标准差 参考 方差（Variance）和标准差（Standard Deviation） 平均值(Mean)、方差(Variance)、标准差(Standard Deviation)]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo升级]]></title>
    <url>%2F2018%2F01%2F24%2Fhexo-update%2F</url>
    <content type="text"><![CDATA[hexo博客托管在github上，github自带的代码检测发现文件 package-lock.json 中的依赖包marked@0.3.6有安全漏洞，然后在我的项目头部给了个醒目的报警，并且建议我将marked插件升级到0.3.9。原来的package-lock.json是这样的： 12345678910111213141516"hexo-renderer-marked": &#123; "version": "0.3.0", "resolved": "https://registry.npmjs.org/hexo-renderer-marked/-/hexo-renderer-marked-0.3.0.tgz", "integrity": "sha1-X6J6NhB10Ui47P8plSo+FeI67YE=", "requires": &#123; "hexo-util": "0.6.1", "marked": "0.3.6", "object-assign": "4.1.1", "strip-indent": "1.0.1" &#125;&#125;,"marked": &#123; "version": "0.3.6", "resolved": "https://registry.npmjs.org/marked/-/marked-0.3.6.tgz", "integrity": "sha1-XXXXXXXXXXXXXXXX"&#125; 折腾一番后，我把该文件修改如下： 12345678910111213141516"hexo-renderer-marked": &#123; "version": "0.3.0", "resolved": "https://registry.npmjs.org/hexo-renderer-marked/-/hexo-renderer-marked-0.3.0.tgz", "integrity": "sha1-X6J6NhB10Ui47P8plSo+FeI67YE=", "requires": &#123; "hexo-util": "0.6.1", "marked": "0.3.9", "object-assign": "4.1.1", "strip-indent": "1.0.1" &#125;&#125;,"marked": &#123; "version": "0.3.9", "resolved": "https://registry.npmjs.org/marked/-/marked-0.3.9.tgz", "integrity": "sha512-nW5u0dxpXxHfkHzzrveY45gCbi+R4PaO4WRZYqZNl+vB0hVGeqlFn0aOg1c8AKL63TrNFn9Bm2UP4AdiZ9TPLw=="&#125; 上面要填哈希验证码，从哪里获取0.3.9版本的marked插件的hash验证码呢，我随便找了个目录，然后： npm install marked@0.3.9 --save 在该目录下就生成了个文件，里面就有我要的哈希。在hexo网站的根目录下，执行 npm install，然后再次部署网站后，终于没有报错。 后来发现，一个更简便的方法是直接在hexo网站根目录下执行： npm install marked@0.3.9 --save 然后我看 node_modules 文件夹下，marked插件也更新了，package-lock.json文件中marked插件的版本号也修改了，不同于上面，在hexo文件夹下的文件 package.json 中dependencies节点下添加了marked依赖。这种操作我没有最终hexo部署看是否生效，但是我觉得应该是没问题的。 这次更新插件暴露出一个问题，我需要对hexo框架以及npm加强理解。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解一下肺结核]]></title>
    <url>%2F2018%2F01%2F24%2Ftuberculosis-study%2F</url>
    <content type="text"><![CDATA[家里一伯伯有肺结核，周围人对肺结核了解很少，我知道恐惧和偏见比肺结核本身更可怕。所以决定了解一下肺结核（tuberculosis）。 占坑]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习npm]]></title>
    <url>%2F2018%2F01%2F24%2Fnpm-study%2F</url>
    <content type="text"><![CDATA[npm基本使用安装插件：npm install 插件名 –save安装指定版本的插件，例如安装插件3.8.0版本的lodash：npm install lodash@3.8.0 卸载插件：npm uninstall 插件名 参考 npm中如何下载特定的组件版本]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员用英语——词汇篇]]></title>
    <url>%2F2018%2F01%2F24%2Fprogrammer-used-English-words%2F</url>
    <content type="text"><![CDATA[programmer 程序员 security vulnerability 安全漏洞 mean 平均值 variance 方差 Standard Deviation 标准差]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抢票攻略]]></title>
    <url>%2F2018%2F01%2F24%2Fsnatch-tickets-strategy%2F</url>
    <content type="text"><![CDATA[先学个英语：snatch CNY train tickets 春运抢票 CNY 两个常用意思： 人民币（China Yuan） 中国新年（Chinese New Year） 例句： 春运高峰将至，这些带有抢票插件的浏览器能够帮助人们在铁道部官方订票网站12306.cn上购得车票，因而大受欢迎。 Thee browsers have add-ons designed to help people buy seats at 12306. cn, the Railways Ministry&apos;s official ticketing website, and have been popular before the Spring Festival travel rush. 因为春节放假具体哪一天还不能完全确定，先用抢票工具抢了两张票，然后等时间确定了些了，再退掉其中一张。 题外话，上图作了样式处理，设置图片大小，并且居中。 &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://XXX/XXX.jpg&quot; width = &quot;40%&quot;/&gt; &lt;/div&gt; 开车时间前15天（不含）以上不收取退票费，然后是48小时，24小时会收退票费，算好时间，15天，48小时，24小时，这几个关键的时间点，对于自己退票或抢漏都是个不错的时间点。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow学习]]></title>
    <url>%2F2018%2F01%2F23%2FTensorFlow-study%2F</url>
    <content type="text"><![CDATA[慕课网上的课程质量很高，找个老师入门先。 什么是TFTensorFlow是Google开源的基于数据流图的科学计算库，适合用于机器学习。Tensor：张量Flow：流动合起来就是张量在图中流动的意思。 TF的详细架构 TF的特点 灵活性：只要可以将计算表示成数据流图，就可以使用TF 跨平台：Linux，Windows，Android，IOS，Raspberry Pi等等 多语言：上层开发语言 Python，C++，Java，Go等等 速度快：包含了XLA这款强大的线性代数编译器 上手快：Keras，Estimiators等高层API 可移植：代码几乎不加修改移植到CPU，GPU，TPU等等 使用TF的中国公司 参考 基于Python玩转人工智能最火框架TensorFlow应用实践 TensorFlow官网 TensorFlow与主流深度学习框架对比]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html学习]]></title>
    <url>%2F2018%2F01%2F23%2Fhtml-study%2F</url>
    <content type="text"><![CDATA[form标签的 enctype 属性1234&lt;form name="form1" action="/manage/product/upload.do" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="upload_file" /&gt; &lt;input type="submit" value="springmvc上传文件" /&gt;&lt;/form&gt; enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。默认地，表单数据会编码为 “application/x-www-form-urlencoded”。就是说，在发送到服务器之前，所有字符都会进行编码。enctype的值为“multipart/form-data”，在使用包含文件上传控件的表单时，必须使用该值。 提交一个form表单，除了上文用的： 1&lt;input type="submit" value="springmvc上传文件" /&gt; 另一种方法是： 1&lt;div onclick="document.getElementById('Form_Name').submit();" /&gt; form元素写法是： 123&lt;form id="Form_Name" onSubmit="return check(this);" &gt; &lt;!-- test --&gt;&lt;/form&gt; 表单的onSubmit事件用于对表单内容进行验证，onSubmit函数的返回值为false时，表单不会提交。 html中的元素html中的元素，大致可以分为两类，行级元素和块级元素。行级元素又称内联元素，在一行中水平排列，行内元素的高度由其内容撑开，不可显式地设置其高度，块级元素可通过 css 的 display:inline 变成行级元素。块级元素一般是其他元素的容器，其宽度、高度都是可设置的，默认每次占用一整个行，非块级元素可通过 css 的 display:block 将其改成块级元素，任何一个块级元素，均可以用Box model解释说明。行级元素：span input a li img块级元素：p ul form div h1~h6ul（unordered list 无序列表） div的居中问题div中的文字需要垂直居中的话，设置div的 line-height 属性，设成与div的 height 属性一样就行了。如果要把该div设成在外面的div或form中水平居中，则设置该div的属性 margin:0 auto 绝对定位绝对定位使元素的位置与文档流无关，也不占据文档流空间，普通流中的元素布局就像绝对定位元素不存在一样。 html5的新标签标签是html5的新标签，目前所有浏览器都不支持标签。 前端的难点浏览器的兼容性，PC端与移动端的兼容性。 CSS 伪元素CSS 伪元素用于向某些选择器设置特殊效果。例如，content属性与:before及:after伪元素配合使用，来插入生成内容。 123a:after &#123; content:attr(href)&#125; 作用于正面的html 123&lt;p&gt; &lt;a href="www.baidu.com"&gt;百度&lt;/a&gt;&lt;/p&gt; 显示效果是：百度www.baidu.com]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpSession学习]]></title>
    <url>%2F2018%2F01%2F22%2FHttpSession%2F</url>
    <content type="text"><![CDATA[javax.servlet.http.HttpSession是jdk自带的一个interface。在设计业务系统的接口时，有些数据的访问需要先进行权限认证，比如，只有登录用户才能修改个人信息，需要先验证是否是登录用户。这里用session来进行权限判断，因此在接口设计时，每个接口函数的参数列表中都有HttpSession，例如登录接口： 12345@RequestMapping(value = "login.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;User&gt; login(String username, String password, HttpSession session)&#123; //something&#125; 在用户登录成功后，把用户信息记录在session中，session保证在服务器端。 1234ServerResponse&lt;User&gt; response = iUserService.login(username,password);if(response.isSuccess())&#123; session.setAttribute(Const.CURRENT_USER,response.getData());&#125; 当用户查看个人信息时，先判断session中是否有登录用户，有的话，则表明用户处于登录状态，可以查看个人信息。 12345User user = (User) session.getAttribute(Const.CURRENT_USER);if(user != null)&#123; return ServerResponse.createBySuccess(user);&#125;return ServerResponse.createByErrorMessage("用户未登录,无法获取当前用户的信息"); 有些操作需要是管理员权限，通过session来判断用户角色，决定是否有权限操作，这里参考 SpringMVC-study 一文： 12345678910User user = (User)session.getAttribute(Const.CURRENT_USER);if(user == null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"用户未登录,请登录管理员");&#125;if(iUserService.checkAdminRole(user).isSuccess())&#123; //需要管理员权限的操作逻辑放这里 return ServerResponse.createBySuccess(XXX);&#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作");&#125;]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习]]></title>
    <url>%2F2018%2F01%2F22%2Fmybatis-study%2F</url>
    <content type="text"><![CDATA[resultType和resultMapMybatis使用 SQL映射语句文件 来放置对数据库的访问逻辑。MyBatis中在查询进行select映射的时候，返回类型可以用resultType，也可以用resultMap，resultType是直接表示返回类型的，而resultMap则是对外部resultMap的引用，但是resultType跟resultMap不能同时存在。例如，可以在SQL映射语句文件中定义一个resultMap： 1234567&lt;resultMap id="BaseResultMap" type="com.mmall.pojo.User" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="username" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="password" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;/constructor&gt;&lt;/resultMap&gt; 在该SQL映射语句文件中就可以在定义一个select查询时使用这个resultMap： 1234567&lt;select id="selectLogin" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List" /&gt; from mmall_user where username = #&#123;username&#125; and password = #&#123;password&#125;&lt;/select&gt; parameterType 和 parameterMap类似resultMap，如果要在mapper.xml中使用parameterMap，需要先定义一个parameterMap。 1234&lt;parameterMap type="Book.dao.Book" id="BookParameterMap"&gt; &lt;parameter property="bookName" resultMap="BookResultMap" /&gt; &lt;parameter property="bookPrice" resultMap="BookResultMap" /&gt; &lt;/parameterMap&gt; 然后才能使用parameterMap时引用上面定义的BookParameterMap，例如： 123456&lt;insert id="saveBook" parameterMap="BookParameterMap"&gt; insert into BOOK_MANAGE (NAME,PRICE) values (#&#123;bookName&#125;,#&#123;bookPrice&#125;)&lt;/insert&gt; 不推荐使用parameterMap，一般使用parameterType直接将查询结果列值类型自动对应到java对象属性类型上，不再配置映射关系一一对应。多个参数时使用 parameterType=”map”，例如在声明接口时在ProductMapper.java中定义： List&lt;Product&gt; selectByNameAndProductId(@Param(&quot;productName&quot;)String productName,@Param(&quot;productId&quot;) Integer productId); 在ProductMapper.xml中定义对应的sql查询语句为： 12345678910111213&lt;select id="selectByNameAndProductId" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; from mmall_product &lt;where&gt; &lt;if test="productName != null"&gt; and name like #&#123;productName&#125; &lt;/if&gt; &lt;if test="productId != null"&gt; and id = #&#123;productId&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 编写SQL语句注意事项SQL查询语句中，尽量不要使用”select *“,因为数据库表可能会有其他同事添加字段，用“select *”就会返回许多自己并不关心的数据。对于多个sql查询中都会用到的字段集，可以在mapper.xml中声明一个sql id，然后在sql语句中用“include”引用这个sql id。例如上面的： &lt;include refid=&quot;Base_Column_List&quot; /&gt; 先要定义这个Base_Column_List： 123&lt;sql id="Base_Column_List" &gt; id, username, password, email, phone, question, answer, role, create_time, update_time&lt;/sql&gt; #和$的区别#{}表示一个占位符${}表示拼接sql串 //TODO 参考 2 笔记 参考 Mybatis中resultMap和resultType Mybatis中的 ${} 和 #{}区别与用法]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链学习]]></title>
    <url>%2F2018%2F01%2F19%2Fblockchain-study%2F</url>
    <content type="text"><![CDATA[区块链并不是新发明的一种技术，而是一系列技术的集成，包括非对称加密技术、时间戳、共识机制等。以比特币为例，区块链通过时间戳（Timestamp）和工作量证明（Proof of Work）机制解决了双重支付（Double Spending）和拜占庭将军问题（Byzantine Generals’ Problem），即保证同一笔比特币不可能被花费2次，并且在整个去中心化的区块链网络中，在所有节点间保持一致。非对称加密机制保证私钥的安全性，时间戳保证区块按顺序连接成链，工作量证明机制解决了在去中心化系统中如何公平地分发2100万个比特币的问题。区块链技术具有匿名性、去中心化、公开透明等特点。所以，区块链被誉为制造信用的机器。 参考 区块链100问]]></content>
      <tags>
        <tag>Tech.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Unity]]></title>
    <url>%2F2018%2F01%2F18%2FUnity3D-study%2F</url>
    <content type="text"><![CDATA[基本不玩游戏，碰巧看到一个Unity3D的学习资源，为了完善我的知识框架，浅浅地了解一下也是很好的了。此外，我开通博客的初衷之一也是将其作为自己用的资源整理平台。 Unity3D是一款游戏引擎。感谢参考1的课程带我入门，课程中提到Unity官网中提供了一个游戏Demo：angryBots，我搜了下，参考2中是CSDN中找到的安卓安装包，我在手机上安装了下，不错，可以用！github中我也找到angryBots对应的源码，没clone下来在本地跑跑代码，这里就不贴地址了。 关于游戏开发游戏的要素 游戏团队中的角色 策划：设计游戏 美术：制作游戏需要的美术资源 程序员：编写游戏逻辑，整合一切 游戏引擎的作用 减少我们的工作 减少重复开发 降低游戏开发的门槛 关于UnityUnity模块组成 参考 Unity3D快速入门 UNITY3D自带的angryBots项目的android apk包]]></content>
      <tags>
        <tag>program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F01%2F18%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[作为一个编程界的小学生，我真的开始认识到，不管是哪门语言，先努力去掌握一门语言非常重要。抛开语言之争，不管是java、C++还是python或者javascript，先去拿下一门语言。编程语言是计算机世界的通用证，掌握了一门语言后，就可以去恣意遨游，就已经手握计算机世界的钥匙，不管是数据库，驱动，网站，网络，机器学习，乃至一个大分类下的小分类，比如设计模式，数据结构，都可以去大胆探索了。 参考： Design patterns implemented in Java]]></content>
      <tags>
        <tag>program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习]]></title>
    <url>%2F2018%2F01%2F17%2Fspring-study%2F</url>
    <content type="text"><![CDATA[Spring IOCInverse of Control 控制反转某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定。Martin Fowler 提出DI（依赖注入：Dependency Injection）的概念以代替IOC，即让调用者对某一个接口实现类的依赖关系，由第三方（容器或协作类）注入，以移除调用类对某一接口实现类的依赖。Spring通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。Spring为什么会有这种“神奇”的力量？这种神奇的力量归功于java语言本身的类反射功能。把对象的创建和管理交给了Spring去管理，我们需要对象的时候再和Spring去要。 Spring学习的几个好资源 官网spring-framework spring-mvc-showcase-githubspring-mvc-showcase这个例子中有很多SpringMVC的配置，可以参考。 Spring示例-宠物医院-githubspring-petclinic这是一个Spring-boot的例子，这个例子界面友好，可以好好用下！自己写代码里，一些配置文件可以从这个例子来取。 greenhouse-githubgreenhouse spring-boot-githubspring-boot]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习HTTP]]></title>
    <url>%2F2018%2F01%2F15%2Fhttp-study%2F</url>
    <content type="text"><![CDATA[HTTP协议是Hyper Text Transfer Protocol(超文本传输协议)的缩写,是用于从万维网(WWW:World Wide Web )服务器传输超文本到本地浏览器的传送协议。 HTTP协议结构 HTTP请求Request我用Charles截取了一个数据包： POST /user/login.do HTTP/1.1 Host: 101.200.55.136 Content-Length: 29 Accept: application/json; version=1.0 Origin: chrome-extension://aejoelaoggembcahagimdiliamlcdmfm User-Agent: Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.8,en;q=0.6 Cookie: username-101-200-55-136-20000=&quot;2|1:0|10:1513940666|29:username-101-200-55-136-20000|44:ZjE4ZjZlM2U5MmYyNDUwYWEzZDU0ZWYyZTBkZDYyODg=|424b96ebb113bb0c2bc61276895f2073a0ea9a13af0a1f427ad5f2ab7e5bfb4d&quot;; _xsrf=2|13e528d3|441125f8c20b5c571ca5c97ab470a423|1514166814; JSESSIONID=CB627460FB82559BFE1FCF47CBE7642F username=admin&amp;password=admin 一个HTTP请求包括4个部分：以上面的请求为例，第一行，讲了这是一个POST请求，URL为/user/login.do，协议是HTTP/1.1版本第二行至倒数第三行，这是请求头部空行最后一行，请求数据 HTTP请求头部Content-Type客户端发送的实体数据的数据类型，Content-Type:application/json，表示本次请求发送的数据的格式是json。 Accept希望接受的数据类型，Accept:application/json，表示希望接受的数据类型是json格式，即返回的数据必须特别是json格式。 如果在http请求中的header部分不加这Accept参数，在实际请求中会默认加上Accept参数“Accept: */*”，表示可以接受任意返回类型。 如果一个接口在正确请求时返回一个json类型的字符串，倘若在请求的Header部分错误地将Accept参数赋成“text/xml”，则会报错406。错误码406表示Not Acceptable，服务器生成的响应无法被客户端所接受。 参考 关于HTTP协议，一篇就够了 Http报头Accept与Content-Type的区别 HTTP协议详解]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习restful]]></title>
    <url>%2F2018%2F01%2F14%2Frestful-study%2F</url>
    <content type="text"><![CDATA[概念维基百科上给Restful的解释： Representational state transfer (REST) or RESTful web services are a way of providing interoperability between computer systems on the Internet. REST-compliant Web services allow requesting systems to access and manipulate textual representations of Web resources using a uniform and predefined set of stateless operations. 百度百科上的解释： Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 参考3的文章中，阮一峰将对Restful的理解，从 Representational state transfer 的字面单词去理解。阮将这个词组翻译成“表现层状态转化”，几句话很深刻： 所谓&quot;上网&quot;，就是与互联网上一系列的&quot;资源&quot;互动，调用它的URI。 &quot;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&quot;（Representation）。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的&quot;.html&quot;后缀名是不必要的，因为这个后缀名表示格式，属于&quot;表现层&quot;范畴，而URI应该只代表&quot;资源&quot;的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对&quot;表现层&quot;的描述。 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 客户端通过四个HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。 请求方式REST提出的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删）。请求示例： 常见误区“最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。”示例： 从 1 转 500 元给 2： 错误： POST /accounts/1/transfer/500/to/2 正确：（资源不能是动词，但是可以是一种服务） POST /transaction HTTP/1.1 Host: 127.0.0.1 from=1&amp;to=2&amp;amount=500.00 “另一个设计误区，就是在URI中加入版本号” 示例： 错误： http://www.example.com/app/1.0/foo 因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分。 Accept: application/json; version=1.0 参考 4 的视频的最后一小段，讲到Restful风格的几个特点，让我醍醐灌顶。 参考 Representational state transfer RESTful 理解RESTful架构 SpringMVC数据绑定入门 —— RESTful小扩展]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get和post]]></title>
    <url>%2F2018%2F01%2F14%2Fget%26post%2F</url>
    <content type="text"><![CDATA[模拟get请求和post请求get请求如果有参数可以直接加在请求的url后面，方便进行模拟请求。相比来说，模拟post请求复杂些，post请求如果也要传递数据（有参数），有几种方式： 通过构造一个form表单提交数据 12345&lt;form action="form_action.asp" method="post"&gt; &lt;p&gt;First name: &lt;input type="text" name="fname" /&gt;&lt;/p&gt; &lt;p&gt;Last name: &lt;input type="text" name="lname" /&gt;&lt;/p&gt; &lt;input type="submit" value="Submit" /&gt;&lt;/form&gt; ajax和jquery有相应的方法，比如jquery的方法：$.ajax()，$.get()，$.post() 1234567$.ajax(&#123; type: 'POST', url: url, data: data, success: success, dataType: dataType&#125;); 上面的两种方法对于get请求同样适用。$.ajax()的详细用法可以看 $.ajax()方法详解 参考 html中post必须要用form表单吗？ jQuery ajax - post() 方法]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习maven的使用]]></title>
    <url>%2F2018%2F01%2F14%2Fmaven-use%2F</url>
    <content type="text"><![CDATA[maven下载jar包问题eclipse中不能下载jar包依赖，打开windows命令行，在指定目录下： del D:\{XXXX}\*lastUpdate* /a/s 打包mvn clean package mvn clean：清除target目录下的所有文件 在使用mvn package进行编译、打包时，Maven会执行src/test/java中的JUnit测试用例，有时为了跳过测试，会使用参数-DskipTests和-Dmaven.test.skip=true 安装到本地仓库mvn clean install 查看本机的maven配置mvn help:effective-settings 参考 Maven中-DskipTests和-Dmaven.test.skip=true的区别]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么写博客]]></title>
    <url>%2F2018%2F01%2F13%2Fwhy-blog%2F</url>
    <content type="text"><![CDATA[看了不少书，见过不少人。前段时间租的房子到期了，搬家。这才发现工作一年半来，存了不少书。不少人文社科类的书，也有不少专业书籍，看过的与没看的大概一半一半吧。我是个爱书的人，很多书是趁京东的满减大促销买的。搬家的时间才意识到存了一大堆书，这对于一个在京的无产阶级来说是件痛苦的事。搬吧，快递太贵，曾寄了十几本书从北京到郑州，运费150，一公斤10元。这钱基本上赶得上我重买一套了，把手头这套扔了，然后买套新的吧，但转念一想，我选择用快递，既养活了快递公司，同时也是一种低碳生活。看过《断舍离》，对于手上的一本书来说，什么时候可以处理掉呢，也可以问，怎样才算读完了一本书呢？首先，有些特别经典的书对于特定的人来说可能是需要常备手边的，比如，对于一个红学家来说，一本红楼梦的书的是不能扔的。我发现以我现在的水平是讨论不清楚的。参考1，知乎上有个人的问答是“读书就和走路一样，本身不是为了读书，而是为了更高的目标。”，我的理解是，书其实对于人来说是个工具，我们可以借助书来提升自己，将书上的知识内化为我们的技能或智慧。所以，当我们抱着一定目的去读书时，有所收获就是真读到书味了。哪怕是你因为心情忧闷去看了一书笑话大全，然后里面的一个段子把你逗笑了，这就是收获。所以，我觉得囤些书是没毛病的，时不时地去书中的相应章节汲取养分。所以对书的态度，是要区分的，有些好书，经典的书，可以囤着，不时去造访学习。也有些养分不太全的书，一方面在购买时就要仔细甄别，谨慎下单，这种书把养分吸得差不多了，就可以作废品处理了。计算机专业的很多技术书籍，由于技术更新换代太快，这类书可以大胆些处理。所以，读书，关键是从书中汲取养分，我认为一边读书，一边记笔记是个汲取养分的好办法。适时的写博客做读书总结是个好办法。终于扯到正题了。为什么要写博客？文字书写的过程也是一个整理思路的过程，学习的最好办法是教，你能把别人教会了就说明你是真懂了。直接转载不是个好选择，可以把好的文章放在参考链接中，可以是博客中引用里面的好句子。我相信，当你看了一篇好文章，然后你向别人转述时，你的表述跟原文肯定不是完全相同的。功利的角度来说，写博客是一个自我营销的过程。 2018-4-14 15:47:29我自己从自己的博客里受益最多。作为一个开发，不是说做后台，就会一点java就行，在工程中，要用到的技术很多，数据库、linux、uml、设计模式 等等。有了自己的博客后，我就可以把自己的技术栈全部整合到一个博客中，开发中要查个什么资料时，第一查看的，不是google，更不是baidu，而是自己的博客。工作几年后，很多问题我们会反复遇到，真正的全新的问题并不多，所以如果博客做得好的话，工作中遇到的问题都能从自己的博客中找到答案，每次遇到问题再到博客中去做总结，如此良性循环，最后我就能完全消化吸收掉博客上的知识。 待看：参考2 参考 怎样才算读完一本书？ 阮一峰：为什么写博客？（图灵访谈）]]></content>
      <tags>
        <tag>why</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux后台运行程序]]></title>
    <url>%2F2018%2F01%2F10%2Flinux-command-in-backend%2F</url>
    <content type="text"><![CDATA[secureCRT登录一个机器后，在控制台启动一个服务或运行一个程序，这时控制台就监控着这个程序并适时打印日志。想继续使用这个控制台进行其他操作怎么办，或者想关闭控制台退出与服务器的连接怎么办？如何让命令提交后不受本地关闭终端窗口、网络断开连接的干扰呢？关闭控制台，对应的在正打印实时日志的控制台就会中断当前这个进程唉。办法是，让这个进程在后台运行。 重定向日志打印command &gt;temp.txt &amp; 常规的linux命令command后加上“&gt;temp.txt &amp;”表示将该命令的日志打印重定向到temp.txt文件，而不是打印到屏幕上。 screen我在用ngrok进行公网域名映射，上面重定向日志打印的办法不生效，参考2给出了解决方案，用screen。问题是我还没明白，为啥启动ngrok用重定向日志方法不行。 参考 Linux 下让进程在后台可靠运行的几种方法 ngrok 后台运行方法]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于编程语言]]></title>
    <url>%2F2018%2F01%2F04%2Fprogram-language%2F</url>
    <content type="text"><![CDATA[前些时候搬家，对自己所有的东西做了个梳理，小到一本书，一张纸。遵照断舍离的观念，“舍弃对物质的迷恋，让自己处于宽敞舒适，自由自在的空间”，丢了不少东西。找到两页笔记，记录在博客上是个不错的选择，纸质的东西就消失吧。这里要写的一些内容，之前上学时，教师讲过这课，当时基础太差，没学懂，真是惭愧不已。程序设计语言原理，有时间一定要把这本书拾起来好好看看。 对向对象面向对象方法具有3个基本特征： 封装 Encapsulation 继承 Inheritance 多态 Ploymorphism 虽然抽象是面向对象的重要组成部分，但它不是面向对象的特征之一，因为所有的编程语言都需要抽象。判断一门语言是否是面向对象的，通常可以使用继承和多态来加以判断：“面向对象”和“基于对象”都实现了“封装”的概念，但是“面向对象”实现了“继承和多态”，而“基于对象”没有实现这些。例如，javascript语言就是“基于对象”的，它使用一些封装好的对象，调用对象的方法，设置对象的属性，但是它们无法让开发者派生新的类，开发者只能使用现有对象的方法和属性。 pythonpython是一门面向对象的解释型编程语言，不同于编译型语言，代码中的变量必须先定义再使用。对于解释型编程语言：跨平台比较容易，只需要提供我写平台的解释器即可，每个特定平台的解释器负责将源代码解释成特定平台的机器指令即可。 javajava语言即是编译型语言，又是解释型语言，或者说java语言即不是纯粹的编译型语言，也不是纯粹的解释型语言。java程序的执行过程必须经过先编译后解释两个步骤。 java源文件（*.java），使用javac编译 得到：字节码文件（*.class）（与平台无关），使用java解释执行，java中负责解释执行字节码文件的是java虚拟机（JVM） 得到：特定平台的机器码（编者按，想在markdown环境下使用流程图，未生效，我的环境是sublime3 + 插件Markdown Editing + 插件OmniMarkupPreviewer）]]></content>
      <tags>
        <tag>program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok-内网穿透]]></title>
    <url>%2F2018%2F01%2F03%2Fngrok-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[开发需要，要进行内网穿透，在外网测试本地的程序。之前慕名花生壳，搜搜资料，一堆人建议使用ngrok，于是来学学ngrok。感谢参考1的作者，很快就顺利把本地一个nodejs服务映射到了外网。 介绍ngrok是一个反向代理，通过在公共的端点和本地运行的Web服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析和重放。 内网穿透内网穿透即NAT穿透NAT英文全拼是Network Address Translator（网络地址转换器），说白了就是凡是经过NAT发出去的数据包，都会通过一定的端口转换（而非使用原端口）再发出去。 使用方法快速测试的话，nodejs或启动tomcat都可以。这里我选的是nodejs方法，参考这里，我在本地的80端口启了一个服务：然后就是开始使用ngrok将本地的80端口映射一个公网的服务。如果直接看参考1的话，很快，我是windows版的，作者写了个批处理文件，直接运行批处理文件：然后按提示输入要映射的本地端口号，这里是80，然后设置域名前缀，比如这里写chou，这样就能访问了： chou.ngrok.xiaomiqiu.cn 如果使用正规的ngrok教程，官网的教程：Sunny-Ngrokhttp前置域名使用方法大致过程是，先注册，然后开通隧道（先购买，这里我选的是免费版的，然后填隧道信息），在隧道管理中能看到自己的隧道id，这个下面要用，复制下来。填隧道信息时要填该隧道的前置域名，比如我这里写chou，本地端口填127.0.0.1:80，表示对本地的80端口进行映射。然后，在ngrok的首页，下载相应操作系统的ngrok客户端，然后就是启动ngrok客户端了，这里有windows版的启动教程，在命令行中： sunny.exe clientid 上面复制的clientid 然后就可以使用了： chou.free.ngrok.cc 参考 关于ngrok及小米球ngrok 内网穿透]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python2和python3的区别]]></title>
    <url>%2F2017%2F12%2F25%2Fpython2%263%2F</url>
    <content type="text"><![CDATA[基本语法区别printPython2打印时可以不加括号：print ‘hello world’， Python3则需要加括号：print(“hello world”)python3中print必须使用括号，因为它就是一个函数。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笑傲江湖——程序员]]></title>
    <url>%2F2017%2F12%2F22%2FXAJH%2F</url>
    <content type="text"><![CDATA[受马云的一些观点的影响，慢慢觉得互联网江湖，程序世界，与武侠世界多少有几分相似。我是从小看金庸的小说电视剧长大的。 近几天回顾了一下笑傲江湖，买的优酷会员，本来想看吕颂贤版的，我从小是看这一版的。可是没有。于是看了李亚鹏版的，01年刚出来时，也匆匆瞥了几眼，可是珠玉在前，我也没认真看这一版。网上这一版口碑也不错，于是我就看了李亚鹏这版。 对于一个程序员来说，内功是什么？我觉得英语阅读能力可以是。提高看英文技术文档的水平，养成看英文博客的习惯，对于提升自己的技术水平有很大帮助，也是快速解决实际问题的捷径。 2018-1-14 13:33:54总共40集，刷到了第38集，令狐冲帮助任我行杀死了东方不败，任我行又当上了日月神教的教主。五岳并派后，岳不群凭借辟邪剑法当上了五岳盟主。 收获 不要轻易去看电视剧，很容易上瘾。 但行好事，某问前程。令狐冲：“我的命又是什么？我在华山长大，可华山派不要我；学了‘独孤九剑’，可到头来救命的却是‘吸星大法’；不想管事，却当上了一群尼姑的掌门；曾经和魔教仇深似海，可又爱上了魔教教主的女儿。”，类比于我们的技术流，只要时时心中有这么个信仰：用科学去改变世界，用自己的专业知识让世界更好，实现自己的社会价值的最大化。诚能如此，写不写代码又有什么关系，用什么语言，什么框架又有什么关系！ 大丈夫处世，不要拘泥于任何束缚，要随机应变。我善养吾浩然之气，一部充满侠义之气的武侠剧滋养了我心中的侠义之气，这就是我看这部剧的初衷。我想起《师说》中，“是故无贵无贱，无长无少，道之所存，师之所存也。”，“是故弟子不必不如师，师不必贤于弟子，闻道有先后，术业有专攻，如是而已。”，韩愈能打破禁锢，不拘泥于形式，阐明师道的根本，实在是了不起。]]></content>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[薄荷阅读-每日一句]]></title>
    <url>%2F2017%2F12%2F18%2Fmint-reading%2F</url>
    <content type="text"><![CDATA[2017-12-18The universe buries strange jewels deep within us all,and then stands back to see if we can find them. 宇宙把一些奇珍异宝深埋于我们的内心，然后站在一旁看我们能不能找到它们。 2017-12-19You can understand conflict,but you don&apos;t have to live in it. 你可以理解冲突，但不必让自己困于其中。 ## 2017-12-20 Our ultimate goal,after all,is not a good death but a good lift to the very end. 毕竟，我们的终极目标不是“好死”，而是好好活到生命的最后。 2017-12-21We all have the tendency to believe self-doubt and selt-criticism,,but listening to this voice never gets us closer to out goals. 我们很容易陷入自我怀疑和自我批评中，但是听信这些声音并不能让我们接近自己的目标。 ## 2017-12-22 Don&apos;t be pushed around by the fears in your mind.Be led by the dreams in your heart. 别被脑子里的恐惧支配，跟着心里的梦想前进。 2017-12-23Don&apos;t fight the darkness.Don&apos;t even wory about the darkness.Turn on the light and the darkness goes.Turn up that light of pure consciousness.Negativity goes. 不要和黑暗对抗，基于无需忧虑黑暗的存在。打开灯，黑暗自会褪去。而调亮大脑里的灯，负面情绪也会自然褪去。 ## 2017-12-24 Christmas Eve was a night of song that wrapped itself about you like a shawl. But it warmed more than your body. It warmed your heart,filled it,too,with melody that would last forever. 平安夜是被歌声萦绕的夜晚，这歌声就像披巾包裹在你周围。它温暖的不仅是你的身体，还有你的心，它让你的内心也充满永恒的旋律。 2017-12-25My idea of Christmas,whether old-fashioned or modern,is very simple:loving others. Come to think of it,why do we have to wait for christmas to do that? 不管老派还是现代，我认为圣诞节的意义都很简单：爱他人。仔细一想，又何必等到圣诞节才这样做呢？ 2017-12-26Happiness is not the absence of problems,it&apos;s the ability to deal with them. 幸福不是没有麻烦，而是拥有应对麻烦的能力。 ## 2017-12-27 In prosperty our friends know us;in adversity we know our friends. 一贵一贱，交情乃见。 2017-12-28How we seek to spend our time may depend on how much time we perceive ourselves to have. 我们如何生活也许取决于我们觉得自己还有多少时间。 2017-12-29The man who moves a mountain begins by carrying away small stones. 移大山始于运小石。 2017-12-30It does not do to dwell on dreams and forget to live. 沉溺于梦境而忘了生活，是不行的。 2017-12-31For last year&apos;s words belong to last year&apos;s language and next year&apos;s words await another voice. 过往之事已成回响，未来之言静待佳音。 2018-1-1May the New Year bring you new strength,new hope and new dreams. 愿新年带给你新的力量、新的希望和新的梦想。 2018-1-2Darkness cannot drive out darkness;only light can do that.Hate cannot drive out hate;only love can do that. 黑暗无法驱赶黑暗，只有光才能做到。仇恨无法驱赶仇恨，只有爱才能做到。 2018-1-3Focus on what makes you happy,and do what gives meaning to your life. 把心思放在让你事情上，做一些能赋予生命意义的事。 2018-1-4Love is a house with an unshakable foundation and an indestructible roof. 爱是一座房子，有着无法撼动的地基和摧毁不了的屋顶。 2018-1-5You cannot find peace by avoiding life. 逃避生活并不能帮你的内心找到平静。 2018-1-6Maturity is when you stop complaining and making excuses,and start making changes. 成熟，是当你停止抱怨和找借口，并开始做出改变的时候。 2018-1-7You may not control life&apos;s cirsumstances,but getting to be the author of your life means getting to control what you do with them. 你也许无法掌控生活的境遇，但作为命运的书写者意味着你可以决定如何去应对一切。 2018-1-8With adequate planning,passion and perseverance,you can achieve the God-given goals. 有足够的计划、热情和毅力，你就会实现那些伟大的目标。 2018-1-9It is better to be hated for what you are than to be loved for what you are not. 宁愿做真实的自己惹人讨厌，也不要为了被人喜欢而变成另一个人。 2018-1-10It isn&apos;t what you have or who you are or where you are or what you are doing that makes you happy or unhappy. It is whata you think about it. 是否快乐并不取决于你拥有什么、你是谁、你在哪儿或者你在做什么，而取决于你是如何看待这些问题的。 2018-1-11That&apos;s the things about lessons,you always learn them when you don&apos;t expect them or want them. 教训这回事，永远会在你最意想不到或者最不想要的时候到时。 2018-1-12Some beautiful paths can&apos;t be discovered without getting lost. 有些美丽的路，只有迷路了才能找到。 2018-1-13When you&apos;re following your inner voice,doors tends to eventually open for you,even if they mostly slam at first. 听从内心的声音，命运之门终会向你敞开，哪怕它们大多都让你吃过闭门羹。 2018-1-14Things don&apos;t work out the way we hope. You just have to pick yourself up and find a new direction to go in. 事情并不总能尽如人意，跌倒后你只能自己爬起来，找一个新方向继续前行。 2018-1-15Because to suffer and do nothing is to be nothing, while to suffer and do something is to become something. 人如果受苦却什么也不做，则一事无成；如果受苦而能有所作为，则能成就伟大。 2018-1-16Becoming fearless isn&apos;t the point. That&apos;s impossible. It&apos;s learning how to control your fear, and how to be free from it. 重要的不是变得无所畏惧，这是不可能的。重要的是学会如何云掌控自己的恐惧，以及如何从恐惧中解脱出来。 2018-1-17Never put off till tomorrow the fun you can have today. 今天能享受的快乐，永远不要留到明天。 2018-1-18Faith removes limitations. 信念可以消除局限。 2018-1-19In the face of pain there are no heros. 在痛苦面前，没有谁是英雄。 2018-1-20We don&apos;t realize that, somewhere within us all, where does exist a supreme self who is eternally at peace. 我们并没有意识到，在我们内心深处的某个地方，住着一个永远平和超然的自己。 2018-1-21There is only one heroism in the world: to see the world as it is,and to love it. 这世界上只有一种英雄主义：那就是认清生活的真相后，依然热爱生活。 2018-1-22To suffer without complaint is the only lesson we have to learn in this life. 这一生我们唯一需要学会的事情，就是承受苦难，而不报怨。 2018-1-23Life is not always perfect.Like road,it has many bends,ups and downs,but that&apos;s its beauty. 生活并不完美，它就像一条路，总有弯道和起伏，但这也恰恰是它的美丽之处。 2018-1-24It&apos;s OKAY to be scared.Being scared means you&apos;re about to do something really ,really brave. 觉得害怕其实没关系，会害怕说明你即将铸一件真正勇敢的事情。 2018-1-25Just because things hadn&apos;t gone the way I had planned didn&apos;t necessarily mean they had gone wrong. 事情发展不如自己预期，并不一定就意味着不顺利。 2018-1-26I made up my mind not to care so much about the destination,and simply enjoy the journey. 下定决心，别太在意结果，享受过程就好。 2018-1-27Let go of what you can no longer keep.Protect what&apos;s still worth keeping. Believe in love most of all. 那些留不住的东西，放手吧，去守护那些值得留住的。最重要的是，相信爱。 2018-1-28If you want to find happiness, find gratitude. 想要幸福快乐，先学会感恩。 2018-1-29You only get one life.It&apos;s actually your duty to live it as fully as possible. 生命只有一次，你有责任把它活得尽可能充实。 2018-1-30If it is necessary sometimes to lie to others,it is always despicable to lie to oneself. 有时也许有必要骗骗别人，但欺骗自己却总是可耻的。 2018-1-31We all need a space,a place in our lives,where we give ourselves the permission to be human,to cry,to be joyous. 我们都需要在生活中空出一出一个位置，在那里我们允许自己做个凡人，可以悲伤大哭，可以开心大笑。 2018-2-1Daring to set boundaries is aboutt having the courage to love ourselves,even when we risk disappointing others. 敢于为自己设立底线就是：哪怕冒着让别人失望的风险，也要有勇气爱自己。 2018-2-2Be a good listener,don&apos;t judge and don&apos;t put boundaries on someone else&apos;s grief. 做一个好的倾听者，不要妄下论断，也不要对别人的悲伤指手画脚。 2018-2-3I may not have gone where I intended to go,but I think I have ended up where I needed to be. 也许没走到最初的目的地，但最终我认为自己还是到达了应该到的地方。 2018-3-7 17:49:12一直跟到了2.14号，程序化地写首页彩图上的每日一句也没啥意思。每日一句彩图如下： 过年放假，薄荷阅读微信也停更了几天。大概2.5号左右，我买了英语流利说的一个月的定制课程，英语流利说的app做得相当赞，免费的轻松学课程也有大量的优质资源，一些付费的发音课程非常好。与薄荷阅读相比，一个注重阅读，一个注重听说。英语是程序员的内功，好好学英语，有这么棒的学习资源，还有什么理由学不好呢。除了上面说的两个app，很多外文网站就是天生的英语学习网站，施一公说自己的经历是通过读《华盛顿邮报》来提高英语阅读和书写能力的，此外《纽约时报》也不错。]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark学习]]></title>
    <url>%2F2017%2F12%2F14%2Fspark%2F</url>
    <content type="text"><![CDATA[Spark是什么Spark是一个快速且通用的集群计算平台。 Spark的特点Spark是快速的Spark扩充了流行的Mapreduce计算模型Spark是基于内存的计算 Spark是通用的Spark的设计容纳了其它分布式系统拥有的功能：批处理、迭代式计算、交互查询和流计算等。优点：降低了维护成本 Spark是高度开放的Spark提供了Python、Java、Scala、SQL的API和丰富的内置库。Spark和其他大数据工具整合得很好，包括hadoop、kafaka等。 Spark生态Spark包括多个紧密集成的组件 Spark Core包含Spark的基本功能，包含任务调度、内存管理、容错机制等。内部定义了RDDs（弹性分布式数据集）。提供了很多APIs来创建和操作这些RDDs。应用场景：为其他组件提供底层的服务。 Spark SQL是Spark处理结构化数据的库，就像Hive SQL，Mysql一样。应用场景：企业中用来做报表统计。 Spark Streaming是实时数据流处理组件，类似Storm。Spark Steaming提供了API来操作实时流数据。应用场景：企业中用来从Kafaka接收数据做实时统计。 Mlib一个包含通用机器学习功能的包，Machine learning lib。包含分类、聚类、回归等，还包括模型评估和数据导入。MLlib提供的上面这些方法，都支持集群上的横向扩展。应用场景：机器学习。 Graphx是处理图的库（例如：社交网络图），并进行图的并行计算。像Spark Streaming、Spark SQL一样，它继承了RDD API。它提供了各种图的操作，和常用的图算法，例如PageRank算法。应用场景：图计算。 Cluster Managers就是集群管理，Spark自带一个集群管理的单独调度器。常见的集群管理包括Hadoop YARN、Apache Mesos Spark与Hadoop比较Hadoop应用场景：离线处理、对时效性要求不高（Hadoop的执行任务时间一般是几分钟到几小时不等。）Hadoop处理数据时的中间数据会保存在硬盘上。 Spark应用场景：时效性要求高的场景（Spark的中间数据尽量保存在内存，Spark任务的计算时间一般是几秒钟到几分钟）Spark适合应用于机器学习领域。 Spark不具有HDFS的存储能力，要借助HDFS等持久化数据。 Spark的ShellSpark的shell使你们能够处理分布在集群上的数据。Spark把数据加载到节点的内存中，因此分布式处理可在秒级完成。快速迭代式计算，实时查询、分析一般能够在shells中完成。Spark提供了Python shell和Scala shells。 提交作业spark-submit RDDsResilient distributed datasets（弹性分布式数据集，简写RDDs），这些RDDs，并行地分布在整个集群中。一个RDD是一个不可改变的分布式集合对象。 val lines = sc.textFile(&quot;/home/test.md&quot;) 上面的lines就是一个RDD，如果对lines进行增删改操作，就会生成了一个新的RDD，而原来的RDD不会改变。Spark中，所有的计算都是通过RDDs的创建，转换操作完成的。一个RDD内部由许多partitions（分片）组成。 分片每个分片包括一部分数据，partitons可在集群不同节点上计算。分片是Spark并行处理的单元，Spark顺序地、并行地处理分片。 RDDs的创建方法1.把一个存在的集合传给SparkContext的parallelize()方法，一般测试中这样使用。 val rdd = sc.parallelize(Array(1,2,2,4),4) //第1个参数：待并行化处理的集合；第2个参数：分区个数 rdd.foreach(println) 2.加载外部数据集 val rddText = sc.textFile(&quot;helloSpark.txt&quot;) RDDs基本操作之Transformation从之前的RDD构建一个新的RDD，例如map()和filter() map()map()接收函数，把函数应用到RDD的每一个元素，返回新的RDD。 filter()filter()接收函数，返回只包含满足filter()函数的元素的新RDD。 flatMap()对每个输入元素，输出多个输出元素。flat压扁的意思，将RDD中元素压扁后返回一个新的RDD。 集合运算RDDs支持数学集合的计算，例如并集，交集计算。去重：distinct()并集：rdd1.union(rdd2)交集：rdd1.intersection(rdd2)减操作：rdd1.subtract(rdd2) RDDs基本操作之ActionAction是在RDD上计算出来一个结果，把结果返回给driver program或保存在文件系统。几个常见的Action操作： reduce()接收一个函数，作用在RDD两个类型相同的元素上，返回新元素。可以实现，RDD中元素的累加，计数，和其他类型的聚集操作。 //计算rdd中元素之和 val sum = rdd.reduce((x,y) =&gt; x+y) collect()遍历整个RDD，向driver program返回RDD的内容。注意：需要单机内存能够容纳下（因为数据要拷贝给driver，测试使用），当数据量很大时，使用saveAsTextFile()操作。 take(n)返回RDD的n个元素（同时尝试访问最少的partitions）,返回结果是无序的，测试使用。 top()排序（根据RDD中数据的比较器） foreach()计算RDD中的每个元素，但不返回到本地。可以配合println()友好地打印出数据。 RDD的特性RDDs的血统关系图Spark维护着RDDs之间的依赖关系和创建关系，叫做血统关系图。Spark使用血统关系图来计算每个RDD的需求和恢复丢失的数据。 延迟计算（Lazy Evaluation）Spark对RDDs的计算是，它们第一次使用action操作的时候，这种方式在处理大数据的时候特别有用，可以减少数据的传输。Spark内部记录metadata信息表明transformations操作已经被响应了。加载数据也是延迟计算，数据只有要必要的时候，才会被加载进去。 RDD.persist()默认每次在RDDs上面进行action操作时，Spark都重新计算RDDs。如果想重复利用一个RDD，可以使用RDD.persist()。unpersist()方法从缓存中移除。RDD.persist()可以传一个参数表明缓存级别： RDDs之KeyValue对例如：包含数行数据的RDD，把每行数据的第一个单词作为keys。 val rdd2 = rdd.map(line =&gt; (line.split(&quot; &quot;)(0),line)) 对KeyValue对的转换操作（Transformations），以{(1,2),(3,4),(5,6)}为例： scala&gt; val rdd = sc.parallelize(Array((1,2),(3,4),(3,6))) rdd: org.apache.spark.rdd.RDD[(Int, Int)] = ParallelCollectionRDD[2] at parallelize at &lt;console&gt;:24 scala&gt; rdd.reduceByKey((x,y) =&gt; x+y) res5: org.apache.spark.rdd.RDD[(Int, Int)] = ShuffledRDD[3] at reduceByKey at &lt;console&gt;:27 scala&gt; res5.foreach(println) (1,2) (3,10) scala&gt; rdd.groupByKey() res7: org.apache.spark.rdd.RDD[(Int, Iterable[Int])] = ShuffledRDD[4] at groupByKey at &lt;console&gt;:27 scala&gt; res7.foreach(println) (1,CompactBuffer(2)) (3,CompactBuffer(4, 6)) combineByKey()：(createCombiner,mergeValue,mergeCombiners,partitioner)最常用的基于key的聚合函数，返回的类型可以与输入类型不一样。许多基于key的聚合函数都用到了它，像groupByKey()。遍历partition（分区）中的元素，元素的key，要么之前见过，要么不是。如果是新元素，使用我们提供的createCombiner()函数，如果是这个partition中已经存在的key，就会使用mergeValue()函数。合计每个partition的结果的时候，使用mergeCombiners()函数。 例如，求平均值： //分别输入jake和mike的三门课分数 scala&gt; val scores = sc.parallelize(Array((&quot;jake&quot;,80.0),(&quot;jake&quot;,90.0),(&quot;jake&quot;,85.0),(&quot;mike&quot;,85.0),(&quot;mike&quot;,92.0),(&quot;mike&quot;,90.0))) scores: org.apache.spark.rdd.RDD[(String, Double)] = ParallelCollectionRDD[0] at parallelize at &lt;console&gt;:24 scala&gt; val scores2 = scores.combineByKey(score =&gt; (1,score),(c1:(Int,Double),newScore) =&gt; (c1._1+1,c1._2+newScore),(c1:(Int,Double),c2:(Int,Double)) =&gt; (c1._1+c2._1,c1._2+c2._2)) scores2: org.apache.spark.rdd.RDD[(String, (Int, Double))] = ShuffledRDD[1] at combineByKey at &lt;console&gt;:26 scala&gt; scores2.foreach(println) (jake,(3,255.0)) (mike,(3,267.0)) scala&gt; val average = scores2.map{case(name,(num,score)) =&gt; (name,score/num)}.collect() average: Array[(String, Double)] = Array((jake,85.0), (mike,89.0)) //得出jake和mike的平均分分别是85.0和89.0。 参考 Spark从零开始 Spark Programming Guide]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown常用]]></title>
    <url>%2F2017%2F12%2F14%2Fmarkdown-commonly-used%2F</url>
    <content type="text"><![CDATA[链接和图片链接：在 Markdown 中，插入链接只需要使用 [显示文本](链接地址 “鼠标放在链接上显示的提示文字”) 即可。图片：在 Markdown 中，插入图片只需要使用 ![显示文本](图片链接地址 “鼠标放在链接上显示的提示文字”) 即可。如果要设置图片的更多属性值，可以用html中的图片标签：，这里设置width属性让显示的图片大小为原图的80%。markdown语法解析插件可以同时解析html语法，加上插件OmniMarkupPreviewer的实时预览功能，这样就能实时显示html文档了，就这相当于是npm中webpack插件的效果了，不错。例如，设置图片大小，并且居中。 &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://XXX/XXX.jpg&quot; width = &quot;40%&quot;/&gt; &lt;/div&gt; 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可分割两段文字内容。 code模式按下四个空格，自动转入Code模式 this is code hello! 分段和换行两个回车是分段，两个空格加上一个回车是回车 列表列表分为有序列表和无序列表两种。无序列表使用星号、加号或是减号作为列表标记，有序列表则使用数字接着一个英文句点，在列表标记上使用的数字并不会影响输出的 HTML 结果，也就是说三条有序记录前面都用“1.”开始，显示出来后仍是“1.”、“2.”、“3.”。 高亮一段代码python： ```python要写的python代码``` 显示如下： 1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' shell： ```bash要写的shell代码``` 显示如下： 1$ hexo new "My New Post"]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala学习]]></title>
    <url>%2F2017%2F12%2F13%2Fscala-study%2F</url>
    <content type="text"><![CDATA[关于scala scala来自单词scalable（可伸缩的） scala是一门纯正的面向对象语言 scala具有函数式编程特性 scala可运行于jvm之上，可以与java无缝互操作 scala的发明者：Martin Odersky 函数式编程就是只用纯函数来编写程序维基百科： In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. 几个关键词： 纯函数（Pure Function），或者函数的纯粹性（Purity），没有副作用（Side Effect） 副作用指状态的变化（Mutation） 例如： 修改全局变量 抛出异常 IO读写 调用有副作用的函数 引用透明性（Referential Transparency）对于相同的输入，总是得到相同的输出不变性（Immutability）：为了获得引用透明性，任何值都不能变化 函数是一等公民（First-class Function）一切都是计算，函数式编程中一切都是表达式，变量、函数都是表达式表达式求值有两种：严格求值（Call By Value）和非严格求值（Call By Name）程序中使用变量的地方，同样可以使用函数，函数可以作为另一个函数的输入或输出。 函数式编程中没有循环语句，使用递归函数（Recursive Function），有一种调优递归的技术叫“尾递归”（Tail Recursion） 函数式编程的优点 生产效率高 易于推理 由于函数式编程没有副作用，具有引用透明性，函数式编程特别适合于并行编程、多核计算、云计算。 三种变量修饰符val定义immutable variable 如果对val修饰的变量重新赋值，会报错： error:reassignment to val var定义mutable variablelazy val：在定义时不会求值，第一次使用时才求值 scala&gt; var a = 20 d: Int = 20 scala&gt; var b = 30 e: Int = 30 scala&gt; lazy val c = a*b g: Int = &lt;lazy&gt; scala&gt; c res0: Int = 600 变量类型scala的类型层级关系图：scala中赋值一个变量时，可以不指定变量类型，系统根据赋的值自动识别出变量的类型： 可以显式指定变量类型： scala&gt; val c:Int = 30 c: Int = 30 也可以不指定变量类型： scala&gt; val d = 30 d: Int = 30 Unit类型相当于java中的void，往往作为函数的返回值类型出现，unit类型返回值的函数，一般表明函数是有副作用的。Null类型的语义与java中Null的语义是一样的，表示一个引用类型的值为空。Nothing的语义是陈述异常终止，如果一个函数的返回值类型为Nothing，表明该函数发生了异常。 scala&gt; def foo() = throw new Exception(&quot;error occurred&quot;) foo: ()Nothing scala中的字符串类型构建于Java的String之上，新增了一个新的特性：字符串插值（interpolation） scala&gt; val name = &quot;chou&quot; name: String = chou scala&gt; s&quot;my name is ${name}&quot; res5: String = my name is chou 代码块Block两种写法：{exp1;exp2}{ exp1 exp2}Block也是一个表达式，其最终求得的值是最后一个表达式的值。 对象在scala中，所有的事物都是对象 方法//方法的返回值类型可以省略，scala自动推断出返回值类型 object test { def hello(name:String):String = { s&quot;Hello,${name}&quot; } //&gt; hello: (name: String)String hello(&quot;chou&quot;) //&gt; res0: String = Hello,chou } 求值策略Scala中有两种求值策略（Evaluation Strategy） Call By Value ：对方法实参求值，且仅求值一次 Call By Name ：方法实参每次在函数体内被用到时都会求值 Scala通常使用Call By Value如果方法形参类型以 =&gt; 开关，那么会使用Call By Name def foo(x: Int) = x //call by value def foo(x: =&gt; Int) = x //call by name 函数一个普通函数： val addOne = (x: Int) =&gt; x + 1 //!!似乎上面的定义与下面是等价的： //def addOne(x: Int) = x + 1 //问题是：上面一行是方法，不是函数？但是柯里化函数是对第二种写法来说的。 println(addOne(1)) // 2 Scala中函数是一等公民Scala语言支持： 把函数作为实参传递给另外一个函数 把函数作为返回值 把函数赋值给变量 把函数存储在数据结构里 在Scala中，函数就像普通变量一样，可以被应用到任何地方，同样也具有函数的类型在Scala中，函数类型的格式为 A =&gt; B ,表示一个接受类型A的参数，并返回类型B的函数。例如：Int =&gt; String 是把整形映射为字符串的函数类型 用函数作为形参或返回值的函数，称为高阶函数。例如，返回值类型为函数的一个方法： def greeting() = (name:String) =&gt; {&quot;hello &quot;+name} 其实函数就是一个从x到y的映射，例如上面的“(name:String) =&gt; {“hello “+name}”就是从一个字符串到另一个字符串的映射，这是一个匿名函数。 关于匿名函数（Anonymous Function）：匿名函数就是函数常量，也称为函数文字量（Function Literal）“val addOne = (x: Int) =&gt; x + 1”相当于是一个函数变量。在Scala里，匿名函数的定义格式为：(形参列表) =&gt; {函数体} 偏应用函数偏应用函数(Partial Applied Function)也叫部分应用函数，跟偏函数(Partial Function)从英文名来看只有一字之差，但他们二者之间却有天壤之别。部分应用函数, 是指一个函数有n个参数, 而我们为其提供少于n个参数, 那就得到了一个部分应用函数。 递归函数在函数式编程中没有循环语句的功能，递归函数（Resursive Function）在函数式编程中是实现循环的一种技术。 def factorial(n: Int): Int = if (n &lt;= 0) 1 else n*factorial(n-1) //&gt; factorial: (n: Int)Int factorial(5) //&gt; res7: Int = 120 递归的一个问题是，如果递归的层次比较深，容易导到栈溢出。一个就应对方案是使用尾递归函数。尾递归函数（Tail Recursive Function）中所有递归形式的调用都出现在函数的末尾。当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录还不是在栈中创建一个新的。 柯里化柯里化函数（Curried Function）把具有多个参数的函数转换为一条函数链，每个节点上是单一参数。示例： def curriedAdd(a: Int)(b: Int) = a + b //&gt; curriedAdd: (a: Int)(b: Int)Int curriedAdd(2)(3) //&gt; res5: Int = 5 //下面的加1函数利用上面字义的curriedAdd函数，第一个参数后面有个下划线表示通配后面的所有参数列表 //利用偏应用函数的柯里化技术来构造新的函数 val addOne = curriedAdd(1)_ //&gt; addOne : Int =&gt; Int = test$$$Lambda$13/434091818@17c68925 addOne(4) //&gt; res6: Int = 5 ## 集合Collections集合包：scala.collection.immutable List空列表Nil scala&gt; Nil res6: scala.collection.immutable.Nil.type = List() 方法head返回第一个元素方法tail返回除第一个元素外的剩余元素组成的列表（尾列表） List的几个高阶函数： 1. filter # 过滤出奇数 scala&gt; List(1,2,3,4).filter(x =&gt; x%2 ==1) // &quot;x =&gt; x%2 ==1&quot;是一个匿名函数，接收一个参数x，参数x的类型不需指定，能够推断出来。 # 这里可以使用通配符_ # List(1,2,3,4).filter(_ % 2 == 1) res0: List[Int] = List(1, 3) # 过滤出字符串中的数字 scala&gt; &quot;95 Red Balloons&quot;.toList.filter(x =&gt; Character.isDigit(x)) res1: List[Char] = List(9, 5) 2. takeWhile # 不满足循环条件时，结束循环取值 scala&gt; &quot;Red Balloons&quot;.toList.takeWhile(x =&gt; x != &apos;o&apos;) res2: List[Char] = List(R, e, d, , B, a, l, l) 3. map #用于对List中的每个元素进行映射处理 scala&gt; val c = List(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) c: List[String] = List(a, b, c) scala&gt; c.map(x =&gt; x.toUpperCase) # 上面的匿名函数可以用通配符进行简写 scala&gt; c.map(_.toUpperCase) res4: List[String] = List(A, B, C) # 使用filter和map scala&gt; List(1,2,3,4).filter(_ % 2 == 1).map(_ + 10) res7: List[Int] = List(11, 13) 两层List scala&gt; val q = List(List(1,2,3),List(4,5,6)) q: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6)) scala&gt; q.map(_.filter(_%2==0)) res8: List[List[Int]] = List(List(2), List(4, 6)) # 用方法flatMap将两层List转成一层List scala&gt; q.flatMap(_.filter(_%2==0)) res9: List[Int] = List(2, 4, 6) 集合的规约操作把集合的元素经过某种操作后变成一个值用reduceLeft计算一个整数集合的元素之和 scala&gt; List(1,2,3).reduceLeft( (x,y) =&gt; x+y) res11: Int = 6 # 两个参数的匿名函数可以使用两个下划线来表示两个参数 scala&gt; List(1,2,3).reduceLeft( _+_ ) res12: Int = 6 # 或者用reduce scala&gt; List(1,2,3).reduce( _+_ ) res13: Int = 6 另外一种规约的方法foldLeft scala&gt; val a = List(2,3,4) a: List[Int] = List(2, 3, 4) scala&gt; a.foldLeft(0)( _ + _ ) res15: Int = 9 scala&gt; a.foldLeft(1)( _ * _ ) res16: Int = 24 整数序列RangeRange的几种写法： 1 to 10 1 to 10 by 2 scala&gt; (1 to 10 by 2).toList res23: List[Int] = List(1, 3, 5, 7, 9) scala&gt; (1 to 9 by 2).toList res24: List[Int] = List(1, 3, 5, 7, 9) scala&gt; Range(1,10,2).toList res25: List[Int] = List(1, 3, 5, 7, 9) 1 until 10 //等同于Range(1,10)，注意，使用util和Range的第二个参数都是开区间，而to的第二个参数是闭区间。 #Range转成List： scala&gt; (1 to 10).toList res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) StreamStream是一个惰性求值的列表（Lazy List）Stream的连接操作符是 #:: //最后是一个空的Stream scala&gt; 1 #:: 2 #:: 3 #:: Stream.empty res2: scala.collection.immutable.Stream[Int] = Stream(1, ?) //Stream(1, ?) 这里第一个元素是确定的，其他元素暂时不求值，用到时才会求值 Range转Stream，用toStream方法： scala&gt; var s = (1 to 1000).toStream s: scala.collection.immutable.Stream[Int] = Stream(1, ?) 对Stream的访问类似List，有head和tail方法： scala&gt; s.head res3: Int = 1 scala&gt; s.tail res4: scala.collection.immutable.Stream[Int] = Stream(2, ?) tuple只有两个元素的tuple称为pairpair的两种写法： scala&gt; (1,2) res5: (Int, Int) = (1,2) scala&gt; 1 -&gt; 2 res6: (Int, Int) = (1,2) 访问tuple中的元素，用下划线加上标号： scala&gt; val t = (1,&quot;chou&quot;,&quot;Math&quot;,95.5) t: (Int, String, String, Double) = (1,chou,Math,95.5) scala&gt; t._1 res7: Int = 1 scala&gt; t._2 res8: String = chou MapMap(key -&gt; value) scala&gt; val p = Map(97 -&gt; &apos;a&apos;,98 -&gt; &apos;b&apos;) p: scala.collection.immutable.Map[Int,Char] = Map(97 -&gt; a, 98 -&gt; b) scala&gt; p(97) res10: Char = a //不存在的key scala&gt; p(1) java.util.NoSuchElementException: key not found: 1 at scala.collection.immutable.Map$Map2.apply(Map.scala:129) ... 29 elided //方法contains用于判断map中是否包含某个key scala&gt; p.contains(1) res11: Boolean = false scala&gt; p.contains(97) res12: Boolean = true //取map的key集合和value集合 scala&gt; p.keys res13: Iterable[Int] = Set(97, 98) scala&gt; p.values res14: Iterable[Char] = MapLike.DefaultValuesIterable(a, b) //scala中添加一条记录 scala&gt; p + (99 -&gt; &apos;c&apos;) res15: scala.collection.immutable.Map[Int,Char] = Map(97 -&gt; a, 98 -&gt; b, 99 -&gt; c) //scala中删除一条记录 scala&gt; p - 98 res16: scala.collection.immutable.Map[Int,Char] = Map(97 -&gt; a) //scala中添加多条记录 scala&gt; p ++ List(100 -&gt; &apos;c&apos;,101 -&gt; &apos;e&apos;) res17: scala.collection.immutable.Map[Int,Char] = Map(97 -&gt; a, 98 -&gt; b, 100 -&gt; c, 101 -&gt; e) //scala中删除多条记录 scala&gt; res17 -- List(97,101) res18: scala.collection.immutable.Map[Int,Char] = Map(98 -&gt; b, 100 -&gt; c) ## 特殊操作符::（两个冒号），联接操作符，用于将左边元素加入右边List，并返回新List scala&gt; val a = List(1,2,3,4) a: List[Int] = List(1, 2, 3, 4) #用联接符将一个元素加入列表，并返回新的列表 scala&gt; val b = 0 :: a b: List[Int] = List(0, 1, 2, 3, 4) #又例如： scala&gt; val c = &quot;x&quot; :: &quot;y&quot; :: &quot;z&quot; :: Nil c: List[String] = List(x, y, z) #上面的操作等同于： scala&gt; &quot;z&quot; :: Nil res0: List[String] = List(z) scala&gt; &quot;y&quot; ::res0 res1: List[String] = List(y, z) scala&gt; &quot;x&quot; :: res1 res2: List[String] = List(x, y, z) :::（三个冒号），联接操作符，用于联接两个List scala&gt; val a = List(1,2,3) a: List[Int] = List(1, 2, 3) scala&gt; val b = List(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;) b: List[String] = List(x, y, z) scala&gt; val c = a ::: b c: List[Any] = List(1, 2, 3, x, y, z) # Int类型与String类型的共同父类是Any 示例快速排序 scala&gt; :paste // Entering paste mode (ctrl-D to finish) def qSort(a: List[Int]):List[Int] = { if(a.length &lt; 2) a else qSort(a.filter(_ &lt; a.head)) ++ a.filter(a.head == _) ++ qSort(a.filter(a.head &lt; _)) } // Exiting paste mode, now interpreting. qSort: (a: List[Int])List[Int] scala&gt; qSort(List(3,1,2,7,5,0)) res19: List[Int] = List(0, 1, 2, 3, 5, 7) spark与scalaspark的内核是用scala来写的。 参考 Scala程序设计—基础篇 Scala中方法和函数的区别 Scala学习笔记(六) Scala的偏函数和偏应用函数 借助Java 8实现柯里化 scala-collections]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode学习使用]]></title>
    <url>%2F2017%2F12%2F12%2Fvscode-use%2F</url>
    <content type="text"><![CDATA[小技巧windows下的vscode，默认使用系统自带的终端cmd，cmd中的清屏命令：cls]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习入门]]></title>
    <url>%2F2017%2F12%2F11%2Fpython-start%2F</url>
    <content type="text"><![CDATA[关于pythonpython是一门面向对象的解释型编程语言，不同于编译型语言，代码中的变量必须先定义再使用。对于解释型编程语言：跨平台比较容易，只需要提供我写平台的解释器即可，每个特定平台的解释器负责将源代码解释成特定平台的机器指令即可。 CPyhton/Pypy/JythonPython是一门编程语言，任何一种编程语言都需要用另一种语言来实现它，比如C语言就是用机器语言来实现的。所以，Python根据实现方式不同分为了CPyhton、Pypy、Jython等。CPython是用C语言实现Pyhon，是目前应用最广泛的解释器。Pypy是用Python自身实现的解释器。Jython是将Python code在JVM上面跑和调用java code的解释器。 python基本数据类型总结 序列python中序列类型有：字符串str、列表list、元组tuple，其中字符串和元组是不可变的，列表是可变的。 &gt;&gt;&gt; type(&apos;abc&apos;) &lt;class &apos;str&apos;&gt; &gt;&gt;&gt; type([1,2,3]) &lt;class &apos;list&apos;&gt; &gt;&gt;&gt; type((1,2,3)) &lt;class &apos;tuple&apos;&gt; 共同特性：1.可以通过序号访问 &gt;&gt;&gt; &apos;abcdef&apos;[1] &apos;b&apos; 2.切片 &gt;&gt;&gt; &apos;abcdef&apos;[1:5] &apos;bcde&apos; &gt;&gt;&gt; &apos;abcdef&apos;[1:5:2] &apos;bd&apos; 3.+和*操作 &gt;&gt;&gt; &apos;ab&apos;+&apos;cd&apos; &apos;abcd&apos; &gt;&gt;&gt; &apos;ab&apos;*3 &apos;ababab&apos; 4.判断一个元素是否在序列中，用in操作 &gt;&gt;&gt; &apos;b&apos; in &apos;abcd&apos; True 5.查看序列中有多少个元素，用len操作 &gt;&gt;&gt; len(&apos;abcd&apos;) 4 6.查看序列中最大最小元素，用max，min &gt;&gt;&gt; max(&apos;abcd&apos;) &apos;d&apos; 集合set集合没有索引，也不能切片 1.差集 &gt;&gt;&gt; {1,2,3,4,5,6} - {3,4,7,8} {1, 2, 5, 6} 2.交集 &gt;&gt;&gt; {1,2,3,4,5,6} &amp; {3,4,7,8} {3, 4} 3.并集 &gt;&gt;&gt; {1,2,3,4,5,6} | {3,4,7,8} {1, 2, 3, 4, 5, 6, 7, 8} 定义一个空集合： &gt;&gt;&gt; type(set()) &lt;class &apos;set&apos;&gt; 字典dictdict也是一种集合 &gt;&gt;&gt; type({97:&apos;a&apos;,98:&apos;b&apos;,99:&apos;c&apos;,100:&apos;d&apos;}) &lt;class &apos;dict&apos;&gt; 通过key值访问一个元素： &gt;&gt;&gt; {97:&apos;a&apos;,98:&apos;b&apos;,99:&apos;c&apos;,100:&apos;d&apos;}[97] &apos;a&apos; key的类型可以是元组，不能是列表： &gt;&gt;&gt; {[1,2]: &apos;b&apos;, 99: &apos;c&apos;, 100: &apos;d&apos;} Traceback (most recent call last): File &quot;&lt;pyshell#30&gt;&quot;, line 1, in &lt;module&gt; {[1,2]: &apos;b&apos;, 99: &apos;c&apos;, 100: &apos;d&apos;} TypeError: unhashable type: &apos;list&apos; &gt;&gt;&gt; {(1,2): &apos;b&apos;, 99: &apos;c&apos;, 100: &apos;d&apos;} {(1, 2): &apos;b&apos;, 99: &apos;c&apos;, 100: &apos;d&apos;} 定义一个空的字典： &gt;&gt;&gt; type({}) &lt;class &apos;dict&apos;&gt; 变量python中的变量的类型不固定 &gt;&gt;&gt; a=1 &gt;&gt;&gt; a=[1,2] #这里可以直接对a赋另一种数据类型的值 值类型与引用类型值类型（不可改变）：int str tuple引用类型（可变）：list set dict #值类型的改变不影响变量b &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = a &gt;&gt;&gt; a = 3 &gt;&gt;&gt; print(b) 1 #引用类型的改变影响变量b &gt;&gt;&gt; a = [1,2,3] &gt;&gt;&gt; b = a &gt;&gt;&gt; a[0] = 5 &gt;&gt;&gt; print(b) [5, 2, 3] 可以改变元组中的列表 &gt;&gt;&gt; a = (1,2,3,4) &gt;&gt;&gt; a[1] = 9 Traceback (most recent call last): File &quot;&lt;pyshell#60&gt;&quot;, line 1, in &lt;module&gt; a[1] = 9 TypeError: &apos;tuple&apos; object does not support item assignment &gt;&gt;&gt; a = (1,2,3,[5,6]) &gt;&gt;&gt; a[3][0] = 8 &gt;&gt;&gt; print(a) (1, 2, 3, [8, 6]) 常用函数&gt;&gt;&gt; a = 1 &gt;&gt;&gt; id(a) #返回对象的内存地址（CPython） 运算符算术运算符&gt;&gt;&gt; 3/2 #除 1.5 &gt;&gt;&gt; 3//2 #整除 1 &gt;&gt;&gt; 2**3 #求幂 8 成员运算符#字典的in运算是针对key值 &gt;&gt;&gt; b = 1 &gt;&gt;&gt; b in {&apos;a&apos;:1} False &gt;&gt;&gt; b = &apos;a&apos; &gt;&gt;&gt; b in {&apos;a&apos;:1} True 身份运算符#身份运算符is 和 not is用于判断两个对应的内存地址是否相同 &gt;&gt;&gt; a = {1,2,3} &gt;&gt;&gt; b = {2,1,3} &gt;&gt;&gt; a == b True &gt;&gt;&gt; a is b False 对象python中一切都是对象，对象的三个特征：值（==）、身份（is/not is）、类型（type）。 # 判断变量的类型： &gt;&gt;&gt; a = &apos;hello&apos; &gt;&gt;&gt; type(a) == int False &gt;&gt;&gt; type(a) == str True # 或者使用isinstance()函数，其中第二个参数可以是个元组 # 用isinstance()函数比用type()函数的另一个优势：可以判断子类型 &gt;&gt;&gt; isinstance(a,str) True while循环while expression: pass else: pass python语法常识 语句后面不需要加分号 不用花括号{}区分代码段，使用缩进区分代码段，因此python代码不能进行混淆压缩。这也是python开源特性的重要原因。 空语句：pass python项目的组织结构包如果要让一个文件夹成为包，则该文件夹下需要一个名称为“init.py”的文件，如果没有这个文件，系统会认为这只是一个普通的文件夹。当一个模块中引入一个包a或才包a中的某个模块时，包a中的文件“init.py”会自动执行。一般会在“init.py”文件中进行包和模块的初始化工作。 模块包test里面的一个py文件就是一个包。包test里的“init.py”这个模块的名字比较特殊，就是叫test。包p1下面的两个模块，模块1要使用模块2中定义的变量： import module1 print(module1.a) 如果模块2在包p1下面的子包p2中： import p2.module1 print(p2.module1.a) # 一个简化路径的方法 import p2.module1 as m print(m.a) 如果只引入某个模块中的某个变量： from p2.module1 import a print(a) from import也可以引入模块： from p2 import module1 print(module1.a) 如果要引入某个模块中的多个变量： #假如在p2.module1中定义了多个变量a、b、c #在新模块module2中： from p2.module1 import a,b,c #这里有个问题，假如import变量很多，需要在代码中换行 #一种方法可以在一行的末尾加个反斜杠“\” from p2.module1 import a,b,\ c #或者： from p2.module1 import (a,b, c) #说明：python中的括号的作用有内括性，连接性 #或者引入所有变量： from p2.module1 import * print(a) print(b) print(c) #假如在新模块module2中只想使用p2.module1中的变量b和c #在p2.module1中定义变量之前，将可以在其他模块直接使用的变量写入模块内置属性__all__： __all__ = [&apos;b&apos;,&apos;c&apos;] #在新模块module2中： from p2.module1 import * #不能直接使用变量a print(b) print(c) #也可以在包中的“__init__.py”文件中赋值__all__模块名列表。 #这样在一个模块中通过from p2.module1 import * #在下面的代码中不能直接使用未在__all__中定义的模块中的变量 在包package1中的“__init__.py”文件中写很多import: import a import b import c 这样在其他模块中要import a、b、c包的话，只用写一句： import package1 就可以使用包a中属性val1: print(package1.a.val1) 包和模块的常见错误 循环引入会导致引入失败：几个模块之间的引入形成闭环 模块b引入模块a，那么执行模块b时，会执行模块a的所有代码 模块内置变量doc：模块注释file：文件所在磁盘的绝对地址package：包名name：文件名对于一个入口文件，上面的内置变量值不同的一般模块：file：文件相对地址package：空值name：main 一个文件，可能作为一个入口文件，也可能作为一个模块被导入，两种情况下的文件代码逻辑可能是不一样的，所以有一段用于检测是否是入口文件的代码： if __name__ == &apos;__main__&apos;: print(&apos;This is app&apos;) print(&apos;This is a module&apos;) 运行一个python文件test1.py，不带其他参数时，默认将test1.py作为入口文件，python命令加上参数-m时，则会将test1.py作为一个模块来运行。两种方式下一些模块内置变量的值会不同。 python内置函数dir([object]) Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object. ipython安装jupyter模块总是不成功： sudo pip install jupyter -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 按照参考4进行配置后，在远程就能在web端访问了，我在本地的浏览器中敲入一段python代码，然后在我的阿里云服务器上云执行，然后在我本地显示出执行结果，太神奇了吧！简直不能太酷。缘起于使用spark中的pyspark，很多RDD的API有待操练。上面没算完，还要设置环境变量如下： export PYSPARK_DRIVER_PYTHON=ipython export PYSPARK_DRIVER_PYTHON_OPTS=&quot;notebook&quot; 这里参考了[7]和[8]。还有一个插曲，ipython要求先安装python2.7以上的版本，可以之前买阿里云时，为了慕课网老师的课程一致，采用了和课程中一样的系统centos6.8，centos6.8自带的python是2.6，于是要安装高版本的python，但是还不能卸载掉原来的python，因为系统工具例如yum只能运行在python2.6之上。这里我参考了[2]，倘不知是否有没有其他副作用。 总之，安装jupyter-notebook，花了不少时间，我一开始只是想把ipthon运行起来，后来经一些文章宣传jupyter-notebook如何如何厉害，我不禁心动。找了不少资料，也看了一些英文，解决了问题，这感觉很棒。 python zen 序列解包可以用一个序列（元组tuple或列表list）对多个变量赋值，这里注意接收的变量的个数必须与序列元素的个数相同，不能多也不能少。 d = 1,2,3 print(type(d)) a,b,c = d print(a,b,c) 结果： &lt;class &apos;tuple&apos;&gt; 1 2 3 参数先定义一个函数 def add(x,y): return x+y 1.必须参数2.关键字参数，例如 c=add(y=3,x=2) 用关键字参数方式进行传参，显式指定每个实参是赋给哪个形参的，这种方式不用保持与函数定义中的参数顺序相同。必须参数与关键字参数，这两种参数类型，在函数定义中没区别，在函数的调用中有区别。 3.默认参数在函数定义时，给形参赋值，在函数调用时，就可以不传默认参数的值。但是这里要注意，函数定义的参数列表中，默认参数后面不能有非默认参数。函数调用时，可以按形参列表顺序给默认参数重赋值，也可以不按形参列表的顺序，以关键字参数的形式给默认参数重赋值。 4.可变参数python会把可变参数列表的实参组装成一个tuple def demo1(*param) print(param) demo1(1,2,3) #等同于 demo1(*(1,2,3)) 等同于： def demo2(param) print(param) # 将要传的多个参数组成一个tuple demo2((1,2,3)) 上面的demo1的调用，不能是：demo1((1,2,3))可以用类似序列解包的方式调用demo1： a=(1,2,3) demo1(*a) 函数参数列表中有可变参数时，可以同时有必须参数和默认参数。 5.关键字可变参数例如：定义一个函数，其参数是多个城市的温度，函数的参数可以用关键字可变参数 def city_temp(**param): print(param) print(type(param)) city_temp(bj=&apos;32c&apos;,xm=&apos;23c&apos;,sh=&apos;31c&apos;) 结果： {&apos;bj&apos;: &apos;32c&apos;, &apos;xm&apos;: &apos;23c&apos;, &apos;sh&apos;: &apos;31c&apos;} &lt;class &apos;dict&apos;&gt; 关键字可变参数：在定义函数时，参数名前加两个星号。所传的关键字可变参数列表相当于是一个字典dict def city_temp1(**param): for key,value in param.items(): print(key,&quot;:&quot;,value) city_temp1(bj=&apos;32c&apos;,xm=&apos;23c&apos;,sh=&apos;31c&apos;) 结果： bj : 32c xm : 23c sh : 31c 等同于： def city_temp2(param): for key,value in param.items(): print(key,&quot;:&quot;,value) city_temp2({&apos;bj&apos;:&apos;32c&apos;,&apos;xm&apos;:&apos;23c&apos;,&apos;sh&apos;:&apos;31c&apos;}) 等同于： city_temp1(**{&apos;bj&apos;:&apos;32c&apos;,&apos;xm&apos;:&apos;23c&apos;,&apos;sh&apos;:&apos;31c&apos;}) 结果同上 变量的作用域for循环外部可以使用for循环内部定义的变量。（这一点与java不同）原因：python中没有块级作用域，而for循环是一个代码块。例如： def demo(): c=50 for i in range(0,9): a=&apos;a&apos; #for循环内部的定义的变量可视为与所属函数同级别的变量，与变量c同是局部变量 c+=1 print(c) print(a) #for循环外部可以引用for循环内部定义的变量a demo() 结果： 59 a 函数外部定义的变量，称为全局变量，其作用域覆盖到函数内部，但是函数内部定义的变量，函数外部不能使用，例如： c=10 #全局变量，即模块级别的变量，不属于任何函数，但是可以被多个函数引用 def demo(): b=12 #局部变量，函数内部定义的变量称作局部变量 print(c) demo() print(b) #这里会报错，变量b未定义，这就是函数外部不能访问局部变量 结果： 10 上面代码print(b)会报错，因为函数外部不能访问局部变量，除非在函数demo中先用关键字global声明变量b，并且在print(b)之前，先调用一下函数demo，使得global声明生效： def demo(): global b b=2 demo() print(b) 结果： 2 模块之间通过import引用后，一个模块内部定义的全局变量，其他模块也能访问到。实际上，所谓全局变量，局部变量，都是个相对的概念，因为python中，函数内部也可以定义函数。python中变量的作用域具有链式特性，称为作用域链。 类类名命令规则：首字母大写，多个单词组合成的类名，每个单词首字母大写。一般将对类的定义以及使用分别放在不同的模块中。类的最基本作用：封装 class Student(): sum=0 #od变量 def __init__(self,name,age) #构造函数，第一个参数名约定为self self.name=name #实例变量name self.age=age self.score=0 self.__score2=0 #这里__score2是一个私有变量 #这里的marking方法是个公有方法，类的外部可以直接访问，如果在定义方法时，方法名前以双下划线开始__marking， #则该方法会被视为私有方法，在类外部不能访问，并提示无该方法，变量的私有或公有同此， #此外，倘若方法名后面双加了双下划线，__marking__，则该方法在类外部又是可以直接访问的， #在python中，前后都有双下划线命名是系统自带的方法和变量 def markig(self,score): if score &lt; 0: print(&apos;不能打负分&apos;) return self.score = scroe print(self.name + &apos;的本次分数为：&apos; + str(self.score)) def fun1(self,name1) #实例方法 self.__class__.sum += 1 #实例方法访问全局变量 print(self.__class__.sum) @classmethod #添加装饰器classmethod，表明方法plus_sum是类方法 def plus_sum(cls): #类方法的第一个参数约定为cls cls.sum += 1 #类方法中操作类变量 print(cls.sum) @staticmethod #添加装饰器staticmethod，表明方法add是静态方法 #能用静态方法的地方都可以用类方法代替。一般，当一个方法与类没有很强的关系时，可以将该方法定义为一个静态方法。 def add(x,y) #不同于实例方法和类方法，静态方法的定义中不需要强制传一个默认参数 print(Student.sum) #静态方法中可以调用类变量 类的使用： student1 = Student(&apos;chou&apos;,18) #调用构造函数，不用传构造函数中的self参数 student1.fun1() #通过对象调用实例方法 Student.plus_sum() #通过类名调用类方法 student1.plus_sum() #也可以通过对象调用类方法 Student.add() #通过类名调用静态方法 student1.add() #也可以通过对象调用静态方法 student1.score = -1 #由于score的可见性为public，所以外部可以直接读写 student1.marking(-1) #对属性值的修改，一般通过调用方法实现 print(student1.__score2) #由于__score2是个私有变量，故此处会报错，提示无该变量 #实际上系统中把__score2改名成了&apos;_Student__score2&apos;存于成员列表中，根据这个重命名规则，可以通过 #print(student1._Student__score2)来访问私有变量&apos;__score2&apos; #由此可见，python中对私有成员的保护机制是很简单的，很容易被破解。 #倘若上面写成： #student1.__score2=-1 #这里就在student1成员列表中添加了一个新的成员&apos;__score2&apos; #print(student1.__score2) #则不会报错，student1.__score2=-1，这里是利用python的动态特性，为对象student1添加了一个新的属性__score2， #不是构造函数中定义的实例变量__score2 #通过：print(student1.__dict__)，会看到对象student1的内部成员列表，可以看到有&apos;_Student__score2&apos;，&apos;__score2&apos; #&apos;_Student__score2&apos;就是构造函数中定义的私有成员变量__score2，&apos;_score2&apos;是后面动态添加的变量 类的继承class Human(): def __init__(self,name,age): self.name=name self.age=age def do_homework(self): print(&apos;This is a parent method&apos;) class Student(Human): #要继承的父类置于类定义后的括号中，这里类Student继承类People def __init__(self,school,name,age): self.school=school #Hman.__init__(self,name,age) #子类中调用父类的构造函数，要注意这里要传第一个参数self，这里实际上是类调用一个实例方法， #是一种普通的方法调用方式，这种方式不推荐，代码不灵活，建议用下面方式： super(Student,self).__init__(name,age) def do_homework(self): super(Student,self).do_homework() #这里会调用父类中的do_homework方法 print(&quot;english homework&quot;) 调用： student1 = Student(&quot;x小学&quot;,&apos;张三&apos;,18) #这里实例化时不需要传self，但是上面的调用父类的构造函数时要传self print(student1.name) print(student1.age) student1.do_homework() #这里不需要传参，因为是用对象调用方法，系统知道对象student1就对应了函数定义中的self #而在子类的构造函数调用父类构造函数时，Hman.__init__(self,name,age) ，需要传self，因为是用类直接调用一个实例方法 #上面student1.do_homework()，如果改为用类来调用该方法，则：Student.do_homework(student1)， #或者传任意一个对象作为参数，例如空字符串：Student.do_homework(&apos;&apos;)，也能正确执行。 正则表达式正则表达式是一个特殊的字符序列，正则表达式由普通字符（例如：’abc’）和元字符（例如：’\d’）构成。有些内置的字符串函数不能解决的问题，可以用正则表达式来实现。 import re str = &apos;abcd1234&apos; #被查找的字符串 reStr = &apos;xxx&apos; #正则表达式 r = re.findall(reStr,str) print(r) 正则表达式规则： &apos;\d&apos; #所有数字 &apos;\w&apos; #单词字符，不包含空格 &apos;.&apos; #除换行符\n以外的其他所有字符 贪婪与非贪婪a = &apos;python 1234java 5&apos; r = re.findall(&apos;[a-z]{3,6}&apos;,a) #{3,6}表示匹配的区间是3到6位 print(r) #默认会以贪婪方式匹配，会打印出python,java 如果： r = re.findall(&apos;[a-z]{3,6}?&apos;,a) #加了个问号，就会以非贪婪方式匹配，会打印pyt,hon,jav（注意，筛选不出java） 匹配0次1次或者无限多次*：匹配0次或者无限多次+：匹配1次或者无限多次?：匹配0次或者1次 边界匹配符r=re.findall(&apos;^\d{4,8}$&apos;,&apos;123456789&apos;) 加了边界匹配符的正则表达式会试图去匹配完整的字符串 边界匹配符，&apos;^&apos;表示开始，&apos;$&apos;表示结束。 组r=re.findall(&apos;(Python){3}&apos;,&apos;PythonPythonPythonPython&apos;) #&apos;(Python){3}&apos;这里查找连续出现在3个Python的地方，注意是圆括号（6个字符是且关系） #&apos;(Python){3}&apos;方括号表示或的关系，表示&apos;Python&apos;中6个字符，匹配3个字符的地方（6个字符是或关系） 运行如下： import re r=re.findall(&apos;(Python){4}?&apos;,&apos;PythonPythonPythonPython&apos;) print(r) r=re.findall(&apos;[Python]{4}?&apos;,&apos;PythonPythonPythonPython&apos;) print(r) 结果： [&apos;Python&apos;] [&apos;Pyth&apos;, &apos;onPy&apos;, &apos;thon&apos;, &apos;Pyth&apos;, &apos;onPy&apos;, &apos;thon&apos;] 把函数作为参数传递给sub，用正则表达式匹配得不同的字符串时，可在函数中针对不同的匹配结果进行不同的替换。 匹配模式参数方法findall有第三个参数，可以不传，传的话，可用于指定匹配模式，多个模式之间用’|’相连，表示且关系。例如：re.I | re.Sre.I表达忽略大小写 函数subsub用于匹配字符串并替换，第二个参数可以是要替换成的字符串，也可以是传一个函数，该函数用于处理匹配得到的字符串： import re def convert(value): #这里的value是一个对象，用group方法得到对应的字符串 matched = value.group() return &apos;!!&apos;+matched+&apos;!!&apos; r=re.sub(&apos;C#&apos;,convert,&apos;PythonC#JavaC#PHPC#&apos;) print(r) 结果： Python!!C#!!Java!!C#!!PHP!!C#!! group分组需求：对于字符串’life is short,i use python’，想要获取到’life’和’python’中间的字符串 import re r = re.search(&apos;life.*python&apos;,&apos;life is short,i use python&apos;) print(r.group()) #group()函数可以传一个数字表明组号，默认group(0) 结果： life is short,i use python 分析： &apos;life.*python&apos;实际是一个分组，可以写成&apos;(life.*python)&apos; 但是，需求是获取中间的字符串&apos; is short,i use &apos; 办法是，在匹配的模式中间加括号： r = re.search(&apos;life(.*)python&apos;,&apos;life is short,i use python&apos;) print(r.group(1)) 这样就会正确得到需要的结果，其中r.group(0)是匹配的完整字符串： is short,i use 也可以改成用findall方法： import re r = re.findall(&apos;life(.*)python&apos;,&apos;life is short,i use python&apos;) print(r) 结果： [&apos; is short,i use &apos;] 多个分组示例： import re r = re.search(&apos;life(.*)python(.*)python&apos;,&apos;life is short,i use python,i love python&apos;) print(r.group(0)) print(r.group(1)) print(r.group(2)) 结果 life is short,i use python,i love python is short,i use ,i love 或者给group函数传多个数字以指定多个组，则会把多个组的结果以元组形式返回： print(r.group(0,1,2)) 结果： (&apos;life is short,i use python,i love python&apos;, &apos; is short,i use &apos;, &apos;,i love &apos;) 或者用groups()函数： print(r.groups()) 结果： (&apos; is short,i use &apos;, &apos;,i love &apos;) JSON什么是jsonjson是一种轻量级（相对于xml而言）的数据交换格式，重点是“json是一种数据格式”。json中的字符串，要求用双引号括起来，因为json格式与语言无关，所以各语言中，json的格式要求是相同的。 正确： json_str = &apos;{&quot;name&quot;:&quot;chou&quot;,&quot;age&quot;:18}&apos; #在javascript中，这个字符串表示一个对象，对应了json中的object数据结构 #对于json中的数组数据结构array，在python中对应的数据结构是列表list： import json json_str2 =&apos;[{&quot;name&quot;:&quot;chou1&quot;,&quot;age&quot;:18},{&quot;name&quot;:&quot;chou2&quot;,&quot;age&quot;:19}]&apos; students = json.loads(json_str2) #这里由字符串到某一种语言的数据类型的解析过程，称为反序列化 print(type(students)) print(students) 结果： &lt;class &apos;list&apos;&gt; [{&apos;name&apos;: &apos;chou1&apos;, &apos;age&apos;: 18}, {&apos;name&apos;: &apos;chou2&apos;, &apos;age&apos;: 19}] #注意：json中有自己定义的一套数据类型规则，与具体语言无关。 错误： json_str = &quot;{&apos;name&apos;:&apos;chou&apos;,&apos;age&apos;:18}&quot; 验证： import json json_str2 = &quot;{&apos;name&apos;:&apos;chou&apos;,&apos;age&apos;:18}&quot; student = json.loads(json_str2) 会报错，属性应该用双引号括起来： JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1) import json json_str = &apos;{&quot;name&quot;:&quot;chou&quot;,&quot;age&quot;:18}&apos; student = json.loads(json_str) #把json字符串转化为字典结构，python中用字典对象来承载json对象表示的信息。 print(type(student)) print(student) 结果： &lt;class &apos;dict&apos;&gt; #不同语言可能会把json字符串解析为不同的数据类型 {&apos;name&apos;: &apos;chou&apos;, &apos;age&apos;: 18} #这里打印了字典内容 序列化/反序列化上面的json.loads()方法是一个反序列化的过程序列化：把python的数据类型向json字符串转换的过程，python中序列化的过程使用方法json.dumps()。 import json students = [{&apos;name&apos;: &apos;chou1&apos;, &apos;age&apos;: 18}, {&apos;name&apos;: &apos;chou2&apos;, &apos;age&apos;: 19}] json_str = json.dumps(students) print(type(json_str)) print(json_str) 结果： &lt;class &apos;str&apos;&gt; [{&quot;name&quot;: &quot;chou1&quot;, &quot;age&quot;: 18}, {&quot;name&quot;: &quot;chou2&quot;, &quot;age&quot;: 19}] 常见错误&gt;&gt;&gt; print &apos;hello&apos;+12 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: cannot concatenate &apos;str&apos; and &apos;int&apos; objects 一本书上看到示例代码中拼接字符串并打印如上代码，原来是书上有误，正确的是先将int转成string &gt;&gt;&gt; print &apos;hello&apos;+str(12) hello12 此外，注意在python3中print函数的参数需要置于括号中，上面的print示例是python2中的语法。 感想python语法灵活，不用常规语法规定也能正确访问变量，调用方法。例如上面提到的访问私有成员，类直接访问成员方法。 参考 Python, CPython, Pypy, Jython的简单介绍 CentOS6.8安装python2.7.12以及ipython教程 pip安装模块报ConnectTimeoutError错误 远程访问Jupyter Notebook Jupyter Notebook 快速入门 IPython和IPython Notebook的安装和简单应用 如何用Jupyter Notebook打开Spark 在 Spark 中使用 IPython Notebook]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习慕课网商城课程]]></title>
    <url>%2F2017%2F11%2F22%2Fmmall_study%2F</url>
    <content type="text"><![CDATA[后台重启nginx./nginx -s reload 平滑重启nginxkill -hup [nginx主进程号] 检查配置文件是否有语法问题./nginx -t 前台安装包的版本一致性npm安装包，注意版本要与课程中的一致：css:0.28.1style:0.17.0extract-text-webpack-plugin:1.0.1 npm执行自定义命令在package.json中定义命令： &quot;scripts&quot;: { &quot;dev&quot;: &quot;WEBPACK_ENV=dev webpack-dev-server --inline --port 8088&quot;, &quot;dist&quot;: &quot;WEBPACK_ENV=online webpack -p&quot;, &quot;dev_win&quot;: &quot;set WEBPACK_ENV=dev &amp;&amp; webpack-dev-server --inline --port 8088&quot;, &quot;dist_win&quot;: &quot;set WEBPACK_ENV=online &amp;&amp; webpack -p&quot; } 在命令行执行自定义命令dev_win：npm run dev_win 参考 Java从零到企业级电商项目实战_服务端 手把手从0打造电商平台_前端开发]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习hibernate]]></title>
    <url>%2F2017%2F11%2F02%2Fhibernate-study%2F</url>
    <content type="text"><![CDATA[参考 Hibernate缓存策略 Hibernate数据缓存攻略 github/qgchou/hibernateSample]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能入门]]></title>
    <url>%2F2017%2F11%2F01%2Fai-start%2F</url>
    <content type="text"><![CDATA[丘成桐：工程上取得很大发展 但理论基础仍非常薄弱,微信中读到这篇文章，评论中有人写道：“现在的人工智能说到底是函数逼近表示，无非是函数的规模和非线性更大更复杂而已。但只要是函数逼近方法，那就有函数的有效作用域，在它规定的作用域内，人工智能可以发挥作用，离开了那个作用域，鬼都不知道会发生什么。要做到真正的普适的人工智能，还需要从基础理论上突破，尤其是机器证明领域的突破。”不明觉厉，故记下来。 什么是AI智能（Intelligence）包括自然智能(Natural Intelligence)和人工智能(Artficial Intelligence) 什么是ML机器学习大致等同于找一个好的函数（Function）/预测模型 Y = f(X) AI、ML 和 DL 的关系机器学习是实现人工智能的一种方法，深度学习是机器学习的一个分支。 监督学习和非监督学习监督学习：Supervised Learning，有标签，近义词：分类（Classification）非监督学习：Unsupervised Learning，没有标签，近义词：聚类（Cluster） 人工智能公司统计： 什么是机器学习利用计算机从历史数据中找出规律，并把这些规律用到对未来不确定场景的决策中。 机器学习与数据分析的区别机器学习处理的是行为数据，传统的数据分析处理的是交易数据。交易数据包括存取款账单、用户订单、话费订单等，而行为数据包括用户的搜索历史、浏览历史、点击历史、评论等。行为数据是海量数据，交易数据是少量数据；对交易数据的一致性要求很高，对行为数据的一致性要求不是那么高；交易数据的一致性用事务来保证，用关系型数据库存储，行为数据用非关系性数据库存储。交易数据可以采用采样分析的办法，行为数据一般用全量分析的方法进行大数据分析，数据量越大，刻画的用户特征越准确。 解决的业务问题不同 技术手段不同 如何选择机器学习算法 机器学习六步走 机器学习的“关键三步” 找一系列函数来实现预期的功能：建模问题 找一组合理的评价标准，来评估函数的好坏：评价问题 快速找到性能最佳的函数：优化问题（比如梯度下降就是这个目的） 各个机器学习库的对比 AI的三个时代 运算智能 感知智能 认知智能 目前处于感知智能阶段。 什么是深度学习基于深度的神经网络的学习研究称之为深度学习。 参考 初识机器学习-理论篇]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习jquery]]></title>
    <url>%2F2017%2F10%2F25%2Fjquery-use%2F</url>
    <content type="text"><![CDATA[一段简单的js： jQuery(function($){ $(&apos;button&apos;).click(function(){ var name = $(this).attr(&apos;name&apos;); $.ajax({ url:&quot;hello.php&quot;, type:&quot;POST&quot;, data:{&apos;search&apos;:name}, success:function(data) { alert(&apos;success&apos;); }, error: function(){ alert(&apos;error&apos;); } }); }); }); 什么时候走success，什么时候走error：ajax的success和error方法根据响应状态码来触发。当XMLHttpRequest.status为200的时候，表示响应成功，此时触发success().其他状态码则触发error()。除了根据响应状态码外，ajax还会在下列情况下走error方法： 返回数据类型不是JSON 网络中断 后台响应中断 异步加载显示等待看ajax()函数的两个参数beforeSend和complete。 参考 ajax在什么情况下会走success和error jQuery ajax - post() 方法 ajax 异步加载显示等待效果 jQuery ajax - ajax() 方法]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习mysql]]></title>
    <url>%2F2017%2F10%2F25%2Fmysql-use%2F</url>
    <content type="text"><![CDATA[授权公司有一小需求，我开发好后，部署在自己的阿里云上，数据库授权，赶紧学了一波。 grant all privileges on hello_db to hello_username@localhost identified by &quot;hello_password&quot;; flush privileges; 上面命令就可以新建一用户，并授予数据库hello_db的所有权限，注意授权后必须FLUSH PRIVILEGES;否则无法立即生效。之前我没有自己的服务器，别人访问我主机数据库时，我就老实把root账号给对方了，一点安全保护意识都没有，不过学生时数据库本来用得也不多，里面自然不会有私人数据。看到一文，navicat创建用户以及设置权限，方便高效，最后我是在图形化界面下设置完成的。之前的命令行操作应该也是有效的，但是命令行下操作权限后，在navicat图形界面下我没看到效果，后来才知道，应该退出navicat再重新打开才生效。 索引数据库索引的两大作用，一是建立索引后可以提高检索速度；二是在高并发的场景下，通过建立唯一索引，可以保证一些业务场景的实现。比如秒杀商品，把用户id和商品id联合建一个唯一索引，这样就从数据库保证了一个用户只能秒杀一件同款商品。 参考 mysql 用户管理和权限设置 Java秒杀系统方案优化 高性能高并发实战]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习使用sublime]]></title>
    <url>%2F2017%2F10%2F24%2Fsublime-use%2F</url>
    <content type="text"><![CDATA[多个编辑点按住ctrl键，可以对一篇sublime设置多个编辑点。 丰富的插件2017-11-30：装了插件用于markdown实时预览(见参考2)，之前写hexo博客用的是idea，idea太耗资源了，启动很慢，装插件后可以方便地用sublime写博客了，棒。装了MarkdownEditing插件后，样式很丑，按照参考4调整一下就好了。另外有个问题，编辑器写一行还没等到换行，先迎来了滚动条，这个很影响书写体验。根据参考4，可以修改一行的最多字符数。修改下面这个值：这个值表示，sublime的markdown模式下的编辑器，一行最多显示99个字符，再多就会自动换行。 感想学习的过程中，听到几个有名的编辑器：vim、atom、vscode，功能强大而且开源，有机会一定会深入学习，顺路在github关注了这三个项目，有这么多优秀的开源工具，真是幸福。我内心是倾向于用vim代替sublime的，毕竟sublime是付费软件，时不时提示我要注册，烦。 2017-11-26 21:36:19这才知道，sublime原来有双击打开和单击半打开的说法，感谢SUN’S BLOG。 2017-11-30 21:17:34参考5，在右侧面板中文件夹右键中添加了一个选项，“git bash”，用git bash打开指定的文件夹，这样，我在sublime中写完博客后就可以很方便打开git bash，然后进行hexo操作了。 快捷键见参考6、7，几个常用快捷键如下：Alt+Shift+2：将sublime分成两栏Ctrl+P：搜索项目中的文件Ctrl+Shift+P：打开命令面板Ctrl+X：删除当前行F11：全屏Shift+F11：全屏免打扰模式，只编辑当前文件Alt+F3：选择所有相同的词Shift+右键拖动：多光标操作，用来更改或插入列内容 装了OmniMarkupPreviewer后Ctrl+Alt+O: 在浏览器实时预览markdown，比如当前这个页面在启动预览模式后，对应的url是http://127.0.0.1:51004/view/34，倘若再用ngrok做一个外网域名映射，就可以很方便在外网访问了，OmniMarkupPreviewer + ngrok就可以很方便地将sublime的笔记分享给别人看了。这种模式还有一个酷炫的特点，你这里在实时写内容，外网获得这个链接的人就能实时看到你写的内容，这就相当于是直播写博客了，这利用了插件OmniMarkupPreviewer的实时预览功能。 编者按：试了下这些快捷键，太激动人心了，以后就用sublime了，妥妥的。 参考 Sublime必备插件之SideBarEnhancements详解 Sublime3下实时预览Markdown插件-MarkdownEditing和OmniMarkupPreviewer Sublime插件：Markdown篇 Sublime Text 3 MarkdownEditing布局设置 Open folder in Git Bash with Sublime Text 2 on Windows sublime text 3 快捷键大全以及配置编译环境 Sublime Text shift+ctrl妙用以及Sublime Text快捷组合键大全 Gif多图：我常用的 16 个 Sublime Text 快捷键]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo学习]]></title>
    <url>%2F2017%2F10%2F24%2Fhexo-use%2F</url>
    <content type="text"><![CDATA[搭建使用 Github 空间搭建 Hexo 技术博客搭建 Hexo 博客–增强篇hexo你的博客 如果换电脑了，怎么更新操作npm install hexonpm installnpm install hexo-deployer-git 修改hexo解决上面的问题“如果换电脑了，怎么更新操作”办法：http://zhujiegao.com/2015/12/06/automatic-backup/ 我的愿景我希望这个博客能取代我的浏览器收藏夹，印象笔记，csdn，博客园，部分日记功能。通过使用这个博客，至少我能学到github的知识和markdown的使用方法。 反馈下体验2017-9-21 21:09:00初衷是要学开源项目ibase4j,由于在eclipse下启不起来，一网友朋友建议我有intellij idea试试，用idea我很顺利地把项目启起来了，于是决定要好好学学idea，上网找教程，找到了judasn的教程，顺路看了下他的博客。一篇介绍用hexo搭博客的教程吸引了我，于是这两天折腾了一下自己的博客，我其实是一个爱学习的人，我非常想学github，想有自己的博客，总是怕麻烦，看着网上教程那么长，心里就打退堂鼓了。要感谢大神Judas.n链接，按照他的博客里的教程，我非常顺利地搭好了自己的博客，然后去买了个域名，一切都很顺利。虽然博客现在还非常粗糙，但我非常高兴能有自己的博客了，博客为我打开了一个新的天地，以后争取以技术博客为主，也许免不了还会有些生活吐槽。 博客当前的问题：md文件没备份到github上，导致我如果换电脑的话，得要手工拷贝md文件，更要命的是，如果我本地的md文件丢失，我的博客就毁了，非常紧急的问题！另外一个问题，qgchou.cn首页要改下，当前是个空白。 学习markdown语法 学习intellij idea 学习git和github 一口吃不成胖子，不要急慢慢来，任何值得拥有的,都是值得等待的。 2017-9-22 10:04:211、我的博客首页是空白2、标签颜色要调整下，太淡了看不出来3、能否设定一些目录仅自己可见，这样就能写一点自己的私人日记 2017-9-28 9:22:56昨天想换下主题，不幸把博客玩死了，主页都打不开。所幸一篇文章救了我：https://www.zhihu.com/question/38219432，邹世杰的答案，“第一删除你hexo 下面的.deploy_git文件夹”。看来得多学学hexo的使用。今天换了个主题：https://github.com/iissnan/hexo-theme-next，选了个github中star最多的。体验一般。还有个问题：我的博客日志通过浏览器搜索不到，怎么回事？ 关于使用七牛七牛云的存储域名外链有时间限制吗？https://segmentfault.com/q/1010000008978229好像没有听说过有“时间限制”这一说，只知道七牛默认给的域名是无法使用 CDN 的，并且七牛官方不保证其稳定性！ 想绑定域名来着，没想到竟然先要将申请的域名在公安网备案，[吐血]，可是我身份证不在手边。。 2017-9-29 11:39:08今天用的hexo-theme-next主题，体验很好！看到一兄弟与我的主题相同：http://suoyo.tech/“markdown 七牛 图 插件”，搜这个关键字想找个七牛传图的插件，但是没找到！！想在hexo博客中大量用些图片还是挺痛苦的。有用的参考：http://error408.com/2016/08/02/Hexo%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8/ 2017-9-29 17:09:11发现一使用图床的利器：极简图床：https://jiantuku.com 2017-9-30 3:22:28虽然这个点了，但还是值得记录一下。1、想用图床，chrome浏览器报安全问题：根本就没办法访问了。只能用360的极速浏览器，但是chrmoe报出的这个安全问题还是值得关注的。2、笔记本电脑的hexo环境又出问题了。一开始我的hexo部在E盘，上次出问题了，我在D盘重新部了一个，今天打开idea，两个hexo，我错把D盘的给删了，又得来重新部，还是有些陌生，故记录一下：基本上是参考：http://www.youmeek.com/hexo/ 和 http://zhujiegao.com/2015/12/06/automatic-backup/（1）、 暂时使用淘宝提供的nodejs源。 alias cnpm=”npm –registry=https://registry.npm.taobao.org \ –cache=$HOME/.npm/.cache/cnpm \ –disturl=https://npm.taobao.org/dist \ –userconfig=$HOME/.cnpmrc”（2）、安装hexo框架 cnpm install -g hexo-cli（3）、创建hexo项目 cd e:/git_work_space/hexo hexo init cnpm install重新生成静态博客的所有内容：hexo generate（4）、将github仓库中的hexo静态文件拷到本地hexo目录 https://github.com/qgchou/hexo.git（5）、安装shelljs模块，以实现自动备份功能 npm install –save shelljs具体的脚本文件在第(4)步已获取。（6）、安装两个跟部署相关的 hexo 插件 cnpm install hexo -server –save cnpm install hexo-deployer-git –save（7）、环境搭建完毕，每次写了新文章后，依次是： hexo clean hexo g hexo d（8）、完善 2017-10-4 19:01:34：集成了第三方服务：评论系统：DISQUS；百度统计；搜索服务：Local Search 关于图床除了用七牛，还可以用新浪微博、github、git.oschina、sm.ms等： github：http://www.jianshu.com/p/33eeacac3344 sm.ms：https://sm.ms/ 2017-10-12 13:34:56发现一个大神的博客：亿界博客,惊叹于博主的手艺高超。在开通博客的初衷之一就是想通过博客取代我的浏览器收藏夹，博主的这个页面：常用网站工具集，正是我想要实现的效果，从博主日志中还写到程序员的简历，哈，通过这个站点来写自己的简历也是极好的。加了博主好友，通过与请教博主加上自己的观察，我知道了可以在markdown中引入js，这样就能在hexo搭建的博客中实现各种酷炫的效果，赞！这给我打开了一扇新的大门，好好学习！想在markdown博客中添加js效果，找到几个资源：在Hexo发布博客的MarkDown文件中引入JS代码 2017-10-24 10:31:27一直使用七牛图床，想把外链域名改成自己的域名，然后看到有个加速域名服务。费劲做了公安网备案，并添加到了网站，然后看到要做域名加速，还有个ICP备案：这个网站，不敢吐槽，找不到备案入口，我这个博客是基于github搭建的，接入商名称是啥，我不知道，网上看ICP备案流程，链接，比较复杂，看来只能做罢了。 2017-10-24 13:16:22我什么都没做！ 2017-12-22 16:20:52之前听人说，写博客有几个阶段，一个阶段是想用hexo等工具搭个自己的博客，到后来，只是想找个地方写博客，反而不热衷于搭自己的博客了，而是更愿意借助于wordpress等平台。我现在有一点感觉了，也看到一点很牛的人是用wordpress写博客，我也不再幼稚地认为hexo比wordpress更高大上了。 2018-1-25 23:01:05我的博客用的是Disqus评论插件，需要验证一下：如果修改的一篇文章，标题或内容，原来这篇文章下的评论还在吗？如果有博文文件为A.md，有一条评论，后来对该博文重名为B.md，那么原来的评论还会在吗？如果后来又新建一条博文，命名也是A.md，之前的评论会附加到这个最发布的博文后面吗？ 2018-3-20 18:48:29hexo生成的html文件以及博客原md文件分别都要保存在github上，我之前是分别建了两个仓库， hexo持久化构建以及给自有域名github-page上HTTPS ，从这篇博客看到的是把这两样放在一个仓库的两个分支里，值得借鉴。 一些可以参考的博客样式李彬molunerfinn 参考 请问大家,使用hexo搭建的博客,使用什么工具写 Markdown 格式博客的? next主题 next第三方服务集成 亿界博客-hexo]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习防火墙]]></title>
    <url>%2F2017%2F10%2F23%2Ffirewall%2F</url>
    <content type="text"><![CDATA[防火墙防火墙主要由服务访问规则、验证工具、包过滤和应用网关4个部分组成，防火墙就是一个位于计算机和它所连接的网络之间的软件或硬件。该计算机流入流出的所有网络通信和数据包均要经过此防火墙。 长城防火墙一般情况下主要指中国对因特网内容进行自动审查和过滤监控、由计算机与网络设备等软硬件所构成的系统。 虽然有了GFW的防护，聪明的兔民还是想方设法到羟外看看，先来看看目前兔民的番羟比例。举个简单例子，现在是2018-2-8 16:00:58，我们来看看明星 吴亦凡 在新浪微博和twitter的粉丝数。粉丝数比较：28485058/84549=337比较wyf的一条微博互动情况：转发数比较：1256761/726=1731点赞数比较：619950/577=1074评论数比较：188229/10=18823从数据上看，可以粗暴地说大概300个兔民中有一个兔民掌握科学上网的方法。当然这是非常粗略的估计，因为wyf的粉丝群不能代表整个兔民群体，wyf的粉丝中肯定有一部分就不是兔国人，twitter粉丝在微博粉丝中不一定分布均匀，twitter和微博的营销策略也不同。再来看看大咖李开复的粉丝数比较：50747920/1726806=29但是呢，lkf是有一定国际影响力的科技大咖，twitter粉丝中肯定有许多国外粉丝，所以我认为如果以这里算出29来作为兔民番羟比例，有些太低了。应该不止29才对。 参考 防火墙 Great Firewall]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github]]></title>
    <url>%2F2017%2F10%2F22%2Fgithub-use%2F</url>
    <content type="text"><![CDATA[提交日期github于2008年才上线，这里却看到05年的提交记录，于是我猜测，这里的提交记录指的是git提交记录，倘若把一个码云的项目导入到github，自然是看到之前在码云上提交的记录。查下历史，果然，Linux内核开发暂时转到GitHub上,11年9月初才把linux内核发布到github了，所以这里看到的提交记录日期指的是git提交日期。 private什么鬼，这里为什么标了个private，难道是私有库吗，但是我不是付费用户唉。访客模式下，看我的主页，不能看到这个仓库。2017-10-31 15:05:03：才发现，原来是之前在学校时申请了个学生优惠包，github针对认证学生免费提供private仓库功能。昨晚打开github时，页面头部有个提示框：毕业了就不好意思再用优惠服务了，执行了DownGrate操作。然后将之前的两个privte仓库设成public。 快捷键仓库页面按下t键：然后输入要找的目录或文件的部分名称。筛选器会在仓库的目录和文件中进行筛选，搜索出您要找的文件。 gistGitHubGist近来用上了gist，虽然被Q了，但是真的觉得gist是个好东西，可以创建 私有 代码片断，具有版本管理功能，提供markdown写作风格。我最看中的是可以创建私有的gist，一些见不得人的东西可以扔里面。看到别人的一段很好的代码时，就可以放在gist中。github中的项目好比一个楼，进去学习观察后，一些好的零部件可以顺走，放在gist中，以后自己要盖楼时，自己的gist就是最好的原材料库。 gitlabGitHub和GitLab是使用Git的代码管理平台，github相当于是公众平台，gitlab相当于私人平台，企业的项目开发一般是托管在自己搭的gitlab上，而不是使用github。gitlab的界面操作与github很相似，但是gitlab是自己搭的服务器，相比于github，在gitlab上操作使用户有更多的自主权。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五笔]]></title>
    <url>%2F2017%2F10%2F21%2Fwubi%2F</url>
    <content type="text"><![CDATA[本科时脑抽筋，决定用五笔。一个好处是记得很多字的写法。我现在一般用搜狗五笔。 快捷键ctrl+shift+A 字根表crtl+shit+? 搜狗辞典 一些没写出来的字“劼”这个字，一开始我写错了编码，lfkt，应该是lfkn，但是输入法词库里没有这个字，我手动添加了。问题是，“力”这个字的第一笔到底是哪个？第一笔是撇所以是T，这刷新了我的认识。 其他使用搜狗五笔，在英文输入法下，常常写着写着就变成了全角字符。搜狗五笔的半全角切换快捷键： shift + 空格]]></content>
      <tags>
        <tag>wubi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些榜样]]></title>
    <url>%2F2017%2F10%2F21%2Fcow-man%2F</url>
    <content type="text"><![CDATA[常常能看到一些技术达人的介绍，他们是我的榜样，勉励自己，虽然我现在还很菜，但梦想还是要有的。20位活跃在Github上的国内技术大牛 天才篇章文嵩 章文嵩：谈LVS及阿里开源背后的精彩故事 LVS 郭家宝 某大牛的招聘进度 赵劼 图灵访谈之三十六：专访赵劼 王垠 英文博客 他不在江湖,但江湖仍有他的传说 一些有意思的人happypeter在慕课网上听一个sublime课程，然后关注了这个讲课老师。理想主义者中的普通人，我觉得对我自己的发展道路参考意义很大。 PengjunJia读《古文观止》，然后在豆瓣的《东周列国志》书评下找到一个中国通史表，很赞，然后找到这个作者。同是历史爱好者。 王然感觉有不少编程高手都在玩二次元啊，常年混迹于A站、B站。这类人一般前端技术很好，喜欢动漫。此外，我知道了，原来除了可以用hexo，还可以直接用gitbook作为博客。 laike9m从王然的博客的评论中找到的一个博主。Google工作唉，啧啧。又是一个二次元。然后看到博主的知乎，我去，清华，中科院计算所，很棒的简历啊。博主说他的博客是用Django搭的，以前常见到一些博客的右上角有到博主的github的链接，觉得很有趣，例如这个linux命令，是Django搭的博客的模板都有这个链接吗。看了博主的关于面试文章，感觉这是第一次离Googler那么近。看了博主的Bad Apple Console，好赞好棒！博主的另一篇文章：是时候了，这篇文章给我留下了深刻印象，里面关于BAT道路的论断值得我思考。 谢恩铭程序员在法国 | 两记棒喝，惊醒梦中人 我之前面试时，也有过类似的遭遇，“我劝你早点转行吧”尤在耳旁，我相信自己可以的！我是不是以后也有可能到国外去工作的机会呢？ 李彬刷微博无意关注到的。同是hexo博客，得好好学习他的博客样式。微博是个好东西，发博点赞评论转发，总能看到博主的真性情。谁还关注了他，以及共同关注，很容易找到志向兴趣相同的人。大隐隐于市，微博中也不乏一些高人，我眼中的高人也有他自己眼中的高人，不断往上索引，源头总是国外某个有名的学者教授，另外一大堆技术卓越的本是国内的高人都移民国外，真是个有趣的发现。索引着索引着，发现一大牛居然是我老乡，不由得虎躯一震，倍受鼓舞。 Revir Yang自由职业者，v2mm的创办人。 smartjinyu感慨，博主段位很高，刚上大学的水平就很高了，可贵的是还开源精神，以及对技术的热爱，这是个真正爱技术的人，望洋兴叹。 CycleUser地质学专业学计算机，翻译了很多国外的CS课程，看他的博客，说话非常谦虚，文学素养也很高。 其他天才周杰伦JayChou是一个极具才华的人，每一段温暖的旋律背后都有许多许多回忆。何谓价值，巨大的影响力加上巨大的正能量，影响了一代人的价值观，在一代人的青春期成长过程中留下深刻的痕迹，这就是JayChou的价值。JayChou出了首新歌《等你下课》，火得不行，网易云音乐上，这首歌的评论每次去看，都有一堆“刚刚”，此刻（2018-1-27 16:14:05）的评论数是806907，这首歌才出来多久啊，可见JayChou的粉丝群有多大。对JayChou暗黑一把，我觉得JC的歌的旋律，曲风非常有个人特色，一听就是JC的味道。之前听了一首《绘梦之卷》，与JC的曲风非常像，知乎上甚至有人问 有哪些歌听起来很像周杰伦但其实并不是他唱的？ 。现在AI作曲已是现实了，我相信以现有的技术模拟一首JC风格的歌曲应该不是难事。 传奇孙正义、马云、坂本龙马 观感太阳底下无新鲜事。偶尔进大牛的微博看看，很多都是些很生活的内容，有些尽是戏谑，和我们普通人其实并无二异，有的甚至更丧。偶然看到一篇有趣的博文，我就想去了解下写文章的人，钱钟书说，“吃了一个鸡蛋,觉得味道很好为什么要去看下蛋的母鸡?”，我的回答是，去了解天才是怎么形成的，对于认识自己和提高自己是有帮助的。尤其是如果能认识一些本专业前辈，对做好自己的职业生涯规划有很大参考意义。关注的一些人才，都是有些计算机背景的，他们爱技术，他们更爱自由，爱生活，而技术除了作为谋生工作外，也为他们追求自由，追求美好生活提供了重要通道。我想，我会成为他们同一批人。当一个人展示其最真实的一面时，总能引起我的一丝共鸣，有时也有一丝感动，真诚是个美好的东西，所以优秀的博主一般来说是个真诚的人。交朋友也是如此，真心待人，肝胆相照，必然会收获别人的真诚的善意。所以，做一个真诚的人。]]></content>
      <tags>
        <tag>man</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome标签同步问题——xmarks]]></title>
    <url>%2F2017%2F10%2F21%2Fchrome-tab-xmarks%2F</url>
    <content type="text"><![CDATA[chrome浏览器简洁的UI风格以及强大的功能吸引了大量拥趸，以前刚接触电脑时，纠结于用哪个浏览器好，本科时留下的一个印象是电脑里装了各种各样浏览器，傲游、世界之窗、枫叶、Opera、极速、IE，当然也是有chrome，然而我当时不做h5，装一堆浏览器纯粹就是想找个最称心的，好比孙悟空到东海找龙王要兵器。最后我还是选择了360的极速浏览器，双核，方便，可以用国内邮箱登录，登录浏览器很重要，这样换电脑或重装系统了，之前浏览器中保存收藏夹等数据还能找得回来，本科时的另一个印象就是装操作系统，另外还要时不时地去学校机房。总之需要登录浏览器保存数据，对于有收藏癖的我来说，能保存收藏夹很重要，这就是我弃用chrome的重要原因。此外还有一个原因，有些系统只能用IE访问，比如某行的网上银行系统。工作后，家里有一台电脑，公司用另一台电脑，浏览器同步的问题又凸显出来了，因为有时会做些h5，而且不时有些科学上网的需求，所以又用起了chrome。 以上为背景 上网找解决方案，大家都是怎么同步 chrome 收藏夹的？,里面提到xmarks，我赶紧试了下，的确不错，墙内就可以在不同浏览器之间同步，不过是国外服务器，同步有点慢。刚刚，我在本机同步了极速浏览器和chrome，我之前同步chrome和firefox做实验，firefox只有个位数的标签，同步没问题，能正常合并。刚才同步极速和chrome出问题了，这两个浏览器我都用了很多时间，还曾经手工导出导入过，所以两个浏览器都有大量的标签，且有很多是相同的，刚才这两个浏览器之间我用xmarks同步，弄丢了几十条标签。唉，做罢，就这样吧。丢了也就算了吧，像我这样留几百个收藏标签的，估计也没啥意义。有些是留了好几年的，一直计划看却是没有看。另外一个隐藏忧虑，要是xmarks被黑客破解，我的个人信息就泄露了，要是哪天xmarks宣布不再提供服务，岂不是就不能用了！我想，最关键的是要放弃收藏癖。 2017-10-25 23:12:52关于xmarks又用于一堆问题，一个基本的原理我没搞清理，所谓的自动同步，是将本地同步到服务器，还是将服务器同步到本地？处于同步状态后，假设我删掉一个标签，点同步操作，是把本地的修改同步到了服务器呢，还是将服务器所保存的数据覆盖掉本地的修改？ 2017-10-26 9:35:37针对上面的疑问，我早上又看了下xmarks的使用，测试，开始时A、B两台机器的标签和服务器一致，都有tab1，然后，在A机器删掉tab1，A机器的xmarks图标提示标签有修改，提示同步，我手动点同步后，再到“My Xmarks”看，服务器上tab1删掉了，然后到B机器上手动点同步，注意，这一步操作就是我昨晚的疑惑，同步方向是怎样的，是会把服务器上的状态同步到B机器呢，还是检测B机器多了一个tab1标签，进而向服务器做一次添加操作，也就是将B机器同步到服务器，那样服务器上的tab1标签又回来了。经验证，是第一种结果，B机器上执行同步后，B机器上的tab1标签也删掉了。这是怎么做到的呢，我猜测，每一次同步操作，服务器会记录一个时间戳，比如上面的例子，A机器9:30同步操作后，就有一个日志，时间戳是9:30。9:50时，B机器执行同步操作时，服务器先查看同步日志，会将B机器的标签同步到9:30时的状态。xmarks图标，黄色表示本地有修改，绿色表示正在进行同步。 2018-4-15 15:57:3我现在的策略是关掉自动同步的选项：真正的操作只用到下面两个按钮： 公司电脑如果有修改收藏夹，在公司电脑上点“upload”，这样就用本机的收藏夹替换掉了xmarks服务器上的收藏夹。然后我回家后，先在浏览器插件上点“download”，这样就用服务器上的收藏夹把家里电脑本机上的收藏夹替掉了。完美解决！现在添加新的收藏的频率很低了，所以这样一个下载，一个上传来达到同步收藏夹的方法还是可以用的。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习linux]]></title>
    <url>%2F2017%2F10%2F20%2Flinux-study%2F</url>
    <content type="text"><![CDATA[find在当前目录下按文件名查找文件example.java： find . -name example.java 上面的用法可以在查看find的man手册。还有个-type参数，可以指定搜索的文件类型：在当前目录搜索文件内容含有某字符串（大小写敏感）的特定文件，xargs展开find获得的结果，使其作为grep的参数：find . -type f -name ‘.sh’ | xargs grep ‘your_string’注意：find命令的查询条件可以使用通配符，上面表示所有.sh格式的文件，通配符是“”，开始时，我以为是“%”，这是与mysql搞混淆了。这里补充一下mysql的模糊查询like： SELECT * FROM user WHERE u_name LIKE ‘张%&apos; “%”表示任意个或多个字符。可匹配任意类型和长度的字符“*”匹配零个或多个在它前面的东西。例如，“x”匹配任何数量的“x”字符，“[0-9]”匹配的任何数量的数字，而“.*”匹配任何数量的任何东西。“.”匹配任何单个的字符。（单字节字符）“[…]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”、“b”或“c”。为了命名字符的一个范围，使用一个“-”。“[a-z]”匹配任何小写字母，而“[0-9]”匹配任何数字。 lsls -lh在Linux中显示文件大小的时候，通常的做法是使用“ls -l”，显示的大小是文件的字节大小。但是，如果文件比较大的话，显示起来不是特别易读，这个时候，可以使用“ls -lh”，就可以使用比较接近文件大小的单位显示文件的大小，如下：第一列，文件属性字段总共有10个字母组成；第一个字符代表文件的类型。 字母“-”表示该文件是一个普通文件字母“d”表示该文件是一个目录，字母”d”，是dirtectory(目录)的缩写注意：目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息字母“l”表示该文件是一个链接文件。字母”l”是link(链接)的缩写，类似于windows下的快捷方式字母“b”的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)字母为“c”表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。字母为“p”表示该文件为命令管道文件。与shell编程有关的文件。字母“s”表示该文件为sock文件。与shell编程有关的文件。 ls /参数为目录，列出指定目录下的内容，”ls /“表示列出根目录下的文件 ## sz/rzsz：将选定的文件发送（send）到本地机器（下载）rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到Linux服务器（上传）安装sz/rz：yum install lrzsz psps命令用于查看系统进程ps -ef是以全格式显示当前所有的进程参数说明： -e 显示所有进程。 -f 全格式 grepgrep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本。grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。grep [option] pattern file参数： -c --count #计算符合样式的行数。 -n --line-number #在显示符合样式的那一行之前，标示出该行的行数编号。 从文件查找关键词：如果待查找的关键词中有双引号比如要查找文件test.c中的”aa”:”bb”，则在命令中在每一个双引号前加一个反斜杠’\’，对应的命令是： cat test.c |grep \&quot;aa\&quot;:\&quot;bb\&quot; 显示上下文： grep -C 5 foo file 显示file文件中匹配foo字串那行以及上下5行（或者 grep -5 foo file） grep -B 5 foo file 显示foo及前5行 grep -A 5 foo file 显示foo及后5行 grep和find的区别find是搜索文件名，查找匹配条件的文件，输出匹配文件grep是搜索文件内容，查找匹配条件的文件行，输出匹配行或含有匹配内容的文件 grep和find的组合使用查找目录 /PATH 中，所有”.h”文件中的含有”helloworld”字符串的文件：find /PATH -name “*.h” | xargs grep -in “helloworld” |管道命令操作符是：”|”,它仅能处理经由前面一个指令传出的正确输出信息，也就是 standard output 的信息，然后，传递给下一个命令，作为标准的输入 standard input。注意： 管道命令只处理前一个命令正确输出，不处理错误输出 管道命令右边命令，必须能够接收标准输入流命令才行。linux shell 管道命令(pipe)使用及与shell重定向区别&gt;和&gt;&gt;输出重定向&gt;和&gt;&gt;的区别linux shell 管道命令(pipe)使用及与shell重定向区别tailtail 命令从指定点开始将文件写到标准输出tail [参数] [文件]-f 循环读取tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不断刷新,使你看到最新的文件内容。例如：tail -f test.log-n 显示多少行例如，显示文件最后5行内容：tail -n 5 test.logtest判断一个命令的结果使用test，其返回0，或一个整数。返回0表示true，返回整数表示错误码test命令是shell环境中测试条件表达式的实用工具获取上一个命令的返回结果使用$？vi在命令模式下： 移动光标类命令h ：光标左移一个字符l ：光标右移一个字符k或Ctrl+p：光标上移一行j或Ctrl+n ：光标下移一行0：（注意是数字零）光标移至当前行首$：光标移至当前行尾) ：光标移至句尾( ：光标移至句首 屏幕翻滚类命令Ctrl+u：向文件首翻半屏Ctrl+d：向文件尾翻半屏 搜索及替换命令/pattern：从光标开始处向文件尾搜索pattern?pattern：从光标开始处向文件首搜索pattern说明：上面的搜索命令，默认是区分大小写的，先输入： :set ignorecase //忽略大小写 进行查找，再输入： :set noignorecase //恢复到大小写敏感 n：在同一方向重复上一次搜索命令N：在反方向上重复上一次搜索命令 撤销及恢复u 撤销上一步的操作ctrl+r 恢复上一步被撤销的操作 进入编辑模式i：在当前字符前插入文本；I：在行首插入文本；o：在当前行后面插入一空行；O：在当前行前面插入一空行； historyhistory命令的作用是记录执行过的命令 列出最近的n条命令history [n] n为数字 使用! 执行历史命令：! number 执行第几条命令! command 从最近的命令查到以command开头的命令执行!! 执行上一条 history命令显示执行时间和执行者： export HISTTIMEFORMAT=”%Y-%m-%d:%H-%M-%S:whoami: “ historyctrl+r 反向查询历史命令使用ctrl+r反向查询历史命令，将匹配的最新一条显示出来如果还想继续向上查询，继续按ctrl+rexportexport命令 用于将shell变量输出为环境变量，或者将shell函数输出为环境变量。一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执 行时，它不会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。 source在当前Shell环境中从指定文件读取和执行命令，命令返回退出状态。 软件安装yumyum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。-y：对所有的提问都回答“yes”；记得刚开始用windows时，很难理解，要安装一个软件，为什么要有两步，先下载一个安装包，再安装，这样文件系统里有两个文件夹，一个放安装包，一个放安装的目录，安装完后能不能删掉安装包？百思不得其解。在linux下用yum安装，就没有我之前的疑惑了。 rpmrpm是由红帽公司开发的软件包管理方式，使用rpm我们可以方便的进行软件的安装、查询、卸载、升级等工作。但是rpm软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个rpm包组成时。rpm -qa|grep mysql-server 可通过这个检查是否已经安装mysql-server-a：查询所有套件-q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户 源码安装软件安装的另一个常用方法是通过源码安装，先安装依赖包，下载源码文件后，三步：./configure –prefix………..makemake install tar解压：tar -zxvf xxx.tar.gzx：从 tar 包中把文件提取出来z：表示 tar 包是被 gzip 压缩过的，所以解压时需要用 gunzip 解压v：显示详细信息f xxx.tar.gz：指定被处理的文件是 xxx.tar.gz toptop命令经常用来监控linux的系统状况，比如cpu、内存的使用，相当于windows系统中的资源管理器。详细请看：Linux top命令的用法详细详解 uname显示linux系统信息，用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 语法uname (选项) 选项-a或--all：显示全部的信息； -m或--machine：显示电脑类型； -n或-nodename：显示在网络上的主机名称； -r或--release：显示操作系统的发行编号； -s或--sysname：显示操作系统名称； -v：显示操作系统的版本； -p或--processor：输出处理器类型或&quot;unknown&quot;； -i或--hardware-platform：输出硬件平台或&quot;unknown&quot;； -o或--operating-system：输出操作系统名称； --help：显示帮助； --version：显示版本信息。 查看发行版本号cat /etc/issue 查看cpu信息lscpu显示cpu架构信息 cat /proc/cpuinfo显示cpu详细信息，可以通过管道加grep，显示指定的信息。 //显示逻辑cpu个数 cat /proc/cpuinfo| grep &quot;processor&quot; 查看内存信息查看/proc/meminfo或者使用free命令 硬盘信息lsblk列出块设备 df查看硬盘使用情况 jpsjps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号，并可通过参数来查看这些进程的详细启动参数。 scp加密的方式在本地主机和远程主机之间复制文件 上传本地文件到远程机器指定目录： scp /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/scptest chmodchmod命令用来变更文件或目录的权限。在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分。用户可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。 u # 操作对象简称，用户user，文件或目录的所有者。 g # 操作对象简称，同组用户group，文件或目录所属群组 o # 操作对象简称，其它用户others a # 操作对象简称，所有用户all，系统默认使用此项 \+ # 权限操作符，添加某些权限 \- # 权限操作符，取消某些权限 = # 权限操作符，设置文件的权限为给定的权限 r # 权限设定（英文），表示可读权限 w # 权限设定（英文），表示可写权限 x # 权限设定（英文），表示可执行权限 \- # 权限设定（英文字符），表示没有权限 示例： chmod u+x,g+w f01 # 为文件f01设置自己可以执行，组员可以写入的权限 chmod u=rwx,g=rw,o=r f01 chmod 764 f01 chmod a+x f01 # 对文件f01的u,g,o都设置可执行属性 head显示指定文件的开头若干行 head(选项)(参数) 选项： -n&lt;数字&gt;：指定显示头部内容的行数； -c&lt;字符数&gt;：指定显示头部内容的字符数； -v：总是显示文件名的头信息； -q：不显示文件名的头信息。 参数： 文件列表：指定显示头部内容的文件列表。 示例： 显示文件test.log的前100行： head -n 100 test.log wc统计文件的字节数、字数、行数 wc(选项)(参数) 选项： -c # 统计字节数，或--bytes或——chars：只显示Bytes数； -l # 统计行数，或——lines：只显示列数； -m # 统计字符数。这个标志不能与 -c 标志一起使用； -w # 统计字数，或——words：只显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串； -L # 打印最长行的长度； -help # 显示帮助信息 --version # 显示版本信息 参数 文件：需要统计的文件列表。 示例 wc -l *.js # 统计当前目录下的所有 .js 后缀的文件行数 tree以树状图列出目录内容，系统默认没有这个命令，需要先安装。 yum和apt-get区别两者都是包管理工作，yum用于RedHat系列的linux系统（Redhat、Centos、Fedora等），apt-get用于Debian系列的linux系统（Debian、Ubuntu等）。 pippip是python软件包管理系统：Pip installs Packages递归缩写 pip install 软件包名 pip uninstall 软件包名 du显示每个文件和目录的磁盘使用空间 md5summd5sum命令 采用MD5报文摘要算法（128位）计算和检查文件的校验和。MD5算法常常被用来验证网络文件传输的完整性，防止文件被人篡改。MD5 全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度就是32位）的“指纹”（或称“报文摘要”），不同的文件产生相同的报文摘要的可能性是非常非常之小的。假设文件内容做了改动，哪怕是微小改动，被修改过以后的文件再次提取“特征码”。结果也会发生翻天覆地的变化，加密学里称之为雪崩效应（avalanche effect）。这种对于数据内容的识别很直接，一眼就能辨别数据内容有无修改。“特征码”识别过程我们好比照妖镜一样，伪装的再好的妖精也会被识别出来。 stat显示文件的状态信息，类比于windows中右键一个文件查看文件属性。访问时间，修改时间等。 netstat查看Linux中网络系统状态信息。 //查看端口占用情况 //udp netstat -nupl //tcp netstat -ntpl 清空一个文件将Linux文件清空的几种方法 参考 linux实用命令 MySql like模糊查询通配符使用详细介绍 export linux命令手册 jps命令使用 UNIX Tutorial for Beginners]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收藏夹]]></title>
    <url>%2F2017%2F10%2F12%2Fmy-favorite%2F</url>
    <content type="text"><![CDATA[技术 站点 易百教程maven repository小众软件V2EXSUN’s BLOG笔记社区 前端 20个不可思议的 WebGL 示例和演示 设计 站酷 小工具 xmarks AI 雷锋网 鸡汤 写给立志做码农的大学生什么是真正的程序员基于深度学习的中文在线抽词-PullWord 科研 站点 科学网 娱乐 电影 neets]]></content>
      <tags>
        <tag>favor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[excel文件导入mysql]]></title>
    <url>%2F2017%2F10%2F12%2Fexcel2mysql%2F</url>
    <content type="text"><![CDATA[用navicat导入excel:WPS表格如何在筛选状态下进行求和？用数据库和用wps自带的筛选求和结果一致：]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习]]></title>
    <url>%2F2017%2F10%2F08%2FSpringMVC-study%2F</url>
    <content type="text"><![CDATA[SpringMVC是一种基于java的实现了webMVC设计模式的请求驱动类型的轻量级web框架，即使用了MVC架构模式的思想。 SpringMVC请求响应的过程： json格式接口慕课网上看一个课程，基于SpringMVC为前台网站写json返回格式的接口。看的两个课程给了两种实现方式。 配置viewResolver参考1的课程中是以这种方式来实现返回json格式接口的。方法是在SpringMVC核心配置文件 dispatcher-servlet.xml中配一个视图解析器。ContentNegotiatingViewResolver可以将同一份数据以呈现出不同的表现形式。 123456789101112131415161718192021&lt;!-- 配置ViewResolver。 可以用多个ViewResolver。 使用order属性排序。 InternalResourceViewResolver放在最后。 --&gt;&lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="order" value="1" /&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;entry key="htm" value="text/html" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;!-- JSON View --&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreAcceptHeader" value="true" /&gt;&lt;/bean&gt; 这里是使用Jackson类库，将模型数据转换成json格式。需要引用依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt; 写Controller时，可以有两种写法： 123456789101112//第一种是用@ResponseBody@RequestMapping(value="/&#123;courseId&#125;",method=RequestMethod.GET)public @ResponseBody Course getCourseInJson(@PathVariable Integer courseId)&#123; return courseService.getCoursebyId(courseId);&#125;//第二种是使用Spring自带的包装类org.springframework.http.ResponseEntity&lt;T&gt;@RequestMapping(value="/jsontype/&#123;courseId&#125;",method=RequestMethod.GET)public ResponseEntity&lt;Course&gt; getCourseInJson2(@PathVariable Integer courseId)&#123; Course course = courseService.getCoursebyId(courseId); return new ResponseEntity&lt;Course&gt;(course, HttpStatus.OK);&#125; 配置 mvc:annotation-driven参考2，在SpringMVC配置文件 dispatcher-servlet.xml 的节点mvc:annotation-driven中加上如下bean 1234567891011&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 参考2的课程中，自定义了一个包装类在包装类 ServerResponse.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)//保证序列化json的时候,如果是null的对象,key也会消失public class ServerResponse&lt;T&gt; implements Serializable &#123; private int status; private String msg; private T data; private ServerResponse(int status)&#123; this.status = status; &#125; private ServerResponse(int status,T data)&#123; this.status = status; this.data = data; &#125; private ServerResponse(int status,String msg,T data)&#123; this.status = status; this.msg = msg; this.data = data; &#125; private ServerResponse(int status,String msg)&#123; this.status = status; this.msg = msg; &#125; @JsonIgnore //使之不在json序列化结果当中 public boolean isSuccess()&#123; return this.status == ResponseCode.SUCCESS.getCode(); &#125; public int getStatus()&#123; return status; &#125; public T getData()&#123; return data; &#125; public String getMsg()&#123; return msg; &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccessMessage(String msg)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(String msg,T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg,data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByError()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorMessage(String errorMessage)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ServerResponse&lt;T&gt;(errorCode,errorMessage); &#125;&#125; 我觉得这个包装类和参考1中提到的org.springframework.http.ResponseEntity作用是相同的。在这个包装类的头部加上如下注解： @JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL) 从而，保证序列化json的时候,如果是null的对象,key也会消失，这非常重要。比如调用公开静态方法createByErrorCodeMessage，没有传data值，接口返回json串时，就不会显示data字段。再比如登录接口，范型T传用户类User，登录成功时： user.setPassword(org.apache.commons.lang3.StringUtils.EMPTY); return ServerResponse.createBySuccess(&quot;登录成功&quot;,user); 这样返回的json串中，有用户的其他信息，但是没有用户的密码字段，非常好！ 写Controller时，所有接口的返回类型都用ServerResponse来封装，因为ServerResponse使用了泛型，所以可以根据需求返回各种数据，比如用户接口，就传入一个用户对象，返回的json串中就会有用户类中的一些属性信息；比如商品管理接口，就传入一个商品对象，返回的json串中就会有商品类中的一些属性信息。有些接口需要返回包含特定的几个字段的json串，又不想去创建一个类，可以在接口中定义一个Map，将想要显示的字段以及内容传入Map对象，因为ServerResponse是一个泛型，因此可以将Map对象传入ServerResponse。例如： 1234567891011121314151617181920@RequestMapping("upload.do")@ResponseBodypublic ServerResponse upload(HttpSession session,@RequestParam(value = "upload_file",required = false) MultipartFile file,HttpServletRequest request)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user == null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"用户未登录,请登录管理员"); &#125; if(iUserService.checkAdminRole(user).isSuccess())&#123; String path = request.getSession().getServletContext().getRealPath("upload"); String targetFileName = iFileService.upload(file,path); String url = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFileName; Map fileMap = Maps.newHashMap(); fileMap.put("uri",targetFileName); fileMap.put("url",url); return ServerResponse.createBySuccess(fileMap); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125;&#125; 几个注解的使用说明@RequestMapping该注解用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径；用于方法上，表示在类的父路径下追加方法上注解中的地址将会访问到该方法。 @ResponseBody@Responsebody 注解表示该方法的返回的结果直接写入 HTTP 响应正文（ResponseBody）中，一般在异步获取数据时使用，通常是在使用 @RequestMapping 后，返回值通常解析为跳转路径，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入HTTP 响应正文中。如上文讲的如果是要写一个json接口，返回接口数据，则要在控制器方法前加上这个注解。如果是要返回某个路径下的页面，则不用加该注解。 参考 Spring MVC起步 从0到上线开发企业级电商项目 浅谈@RequestMapping @ResponseBody 和 @RequestBody 注解的用法与区别]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据与机器学习]]></title>
    <url>%2F2017%2F10%2F04%2FbigData-first%2F</url>
    <content type="text"><![CDATA[大数据如何学好大数据——英文+官网 大数据与X的关系如果把深度学习比作下面的火箭： hadoop狭义Hadoop VS 广义Hadoop Hadoop生态系统 HDFS什么是HDFS通过HDFS，实现数据块多副本的方式进行数据存储。 HDFS优缺点优点： 数据冗余、硬件容错 处理的流式的数据访问（这里的流式指的是一次写入，多次读取的操作） 适合存储大文件 可构建在廉价机器上缺点： 低延迟的数据访问 小文件存储（namenode压力大） 两种方式操作HDFS文件系统-HDFS：shell和java api如果是通过hdfs shell的方式put的上去的那么，才采用hdfs-site.xml中设置了副本系数，如果是通过java api上传上去的，在本地我们并没有手工设置副本系数，所以默认采用的是hadoop自己的副本系数3。 什么是YARNYARN：Yet Another Resource Negotiator负责整个集群资源的管理和调度YARN的特点： 扩展性 容错性 多框架资源统一调度（hadoop1.x版本中只能运行map-reduce作业，hadoop2.x版本中加了YARN这一层，就可以运行不同的框架，例如spark）借助YARN，可以运行多种不同的计算框架，不同的计算框架可以共享同一个HDFS集群上的数据，享受整体的资源调度。XXX on YARN的好处：与其他计算框架共享集群资源，按资源需要分配，进而提高集群资源的利用率XXX: Spark/MapReduce/Storm/Flink YARN的架构YARN架构：1）ResourceManager: RM 整个集群同一时间提供服务的RM只有一个，负责集群资源的统一管理和调度 处理客户端的请求： 提交一个作业、杀死一个作业 监控我们的NM，一旦某个NM挂了，那么该NM上运行的任务需要告诉我们的AM来如何进行处理 2) NodeManager: NM 整个集群中有多个，负责自己本身节点资源管理和使用 定时向RM汇报本节点的资源使用情况 接收并处理来自RM的各种命令：启动Container 处理来自AM的命令 单个节点的资源管理 3) ApplicationMaster: AM 每个应用程序对应一个：MR、Spark，负责应用程序的管理 为应用程序向RM申请资源（core、memory），分配给内部task 需要与NM通信：启动/停止task，task是运行在container里面，AM也是运行在container里面 4) Container 封装了CPU、Memory等资源的一个容器 是一个任务运行环境的抽象 5) Client 提交作业 查询作业的运行进度 杀死作业 YARN执行流程1：client提交请求到RM（用户向YRAN提交一个作业）2：RM为作业分配第一个container，这个container运行在某个NM，RM与对应的NM进行通信3：RM要求在这个NM中启动一个container，这个container用于启动AM4：AM注册到RM，client从而可以通过RM获取到整个作业的运行情况。AM向RM申请整个作业所需的资源。5：AM在对应的NM中启动任务，所有的任务都是以container的形式运行。6：task运行在container中 什么是map-reduce分布式计算框架map-reducemap-reduce处理过程，以word-count为例 什么是hive由facebook开源使用hive对已有的数据进行统计分析：写一个sql，借助于hive的执行引擎，就能把sql语句转换map-reduce，然后提交到集群上进行运算。用于离线分析。 什么是pig由雅虎开源，通过一种脚本的方式，把脚本转换成map-reduce，然后提交到集群上进行运算，也是用于离线分析。 什么是HBase基本Google的论文BigTable的开源实现。用于实时地查询所需的数据。可以当作一个数据库来使用。 SparkSpark是个计算框架。MapReduce基于进程模型，Spark基于线程模型，Spark应用程序启动时会有一个线程池。伯克利将Spark的整个生态系统称为伯克利数据分析栈(BDAS)： 参考 入门大数据 Apache Hadoop YARN]]></content>
      <tags>
        <tag>bigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器]]></title>
    <url>%2F2017%2F10%2F03%2Fcloud-service%2F</url>
    <content type="text"><![CDATA[想操练一下linux命令，我之前用virtualbox建过ubuntu虚拟机，但是我机器配置不高，当前开了许多应用，而开启一个虚拟机是很耗资源的，我又不想把其他应用关掉，于是我来看看云服务器。 国内云服务市场上阿里和腾讯是大户，我之前也有过买云服务器的打算，到相应网站一查，动辄是一个月几百，我一穷屌丝，始终没下决心去买，当时也没想好好学linux。后来工作了，手头稍微宽裕些，域名也买了，vpn也买了，相比于宝贵的学习机会，相比于对自己投资产生的价值，这点钱还是舍得花的。 今天分别到阿里云和腾讯看了下，最便宜的45一个月，其中阿里是由于第一次购云服务所以在原价60基础上有75折优惠。阿里选了个最便宜的“轻量应用服务器”：腾讯云，我选了个最便宜的云服务器：慢着，虽然都是45元一个月（其中阿里云有个75折），但是腾讯云有个按量计费，我想，我用得也不多，也就偶尔练练linux命令，所以决定用腾讯云，充值，购买，用了一会，打算去吃饭了，于是打算关闭云服务器关机，这样就不会收费了，这里有个小插曲，我登录腾讯云服务器后打算关机，我手误写成了init 1，本来是init 0，系统启不起来了，进不去了。后来从网页的控制台进去了，然后重启云服务器，就好了。我想。心里还是有些怀疑，不太确定“按量计费”的意思，于是查了下： http://bbs.qcloud.com/thread-15497-1-1.html 竟然关机也要收费，我赶紧算了下，我买的这个服务器一个月大概多少钱：720（小时）*0.31*0.34=76元我中午时算作：96*0.31+(360-96)*0.31*0.5+(720-360)*0.31*0.34&gt;100了，吓我一跳。我赶紧销毁了这个云服务器，到阿里云上选了个最便宜的。现在看来，虽然中午是我误算了，但比较下来，还是阿里云更便宜些。买了阿里云服务器后，我照提示设置密钥对，并把密钥文件.pem保存在本地，然后设置了root的密码：然后，我打开secureCRT，怎么都登不进去，要我从本地上传一个公钥文件，然而，我没有这个格式的文件唉。由于启用密钥之后，服务器会默认将root账号密码登录的方式禁用掉，如果需要使用账号密码方式登录，需要修改配置文件：1、远程登录服务器2、修改/etc/ssh/sshd_config文件中的PasswordAuthentication no改为PasswordAuthentication yes并保存。3、输入如下命令sudo service sshd restart重启SSH服务,就可以重新使用账号密码连接服务器了。 另外，我用手机登录阿里云客户端，发现这个app里有很多精华内容，值得深入研究下这个app，冰山一角：通过上面的ssh工具，就可以在手机上登录云服务器，可以在里面运行linux命令，就像PC端的secureCRT一样，非常好用。另外阿里云客户端里有大量优质文章，有待学习。 比较“轻量应用服务器”和“云服务器ECS”查资料，似乎最大的区别在于：轻量应用服务器的磁盘使用的是所谓“SSD云盘”，而ECS的磁盘使用的是所谓的“高效云盘”。云盘参数对比：另外云服务最大的优势在于它的可扩展性，在使用过程中，随着业务的扩展，对云服务器进行扩容磁盘、增加带宽。如果不再需要云服务器，也可以方便的释放资源，节省费用。那么，购买的“轻量应用服务器”具体弹性吗？官网有个比较，阿里云轻量应用服务器与普通云服务器和VPS的区别： 云服务器 ECS 与传统 IDC 对比优势 阿里云的使用开启端口安装了一个tomcat，要开放8080端口，我在命令行试了半天试不通，看配置似乎防火墙是关闭状态的：知乎上一个答主建议在平台上来看，果然，添加规则，把8080端口加上就OK了。管理控制台-&gt;安全-&gt;防火墙： 参考 原来阿里云是最最便宜的！不比不知道！ 阿里云-远程连接 云盘参数和性能测试方法 云计算的弹性体现在哪些方面？ 云服务器 ECS 的优势 什么是轻量应用服务器？与阿里云ecs和虚拟主机有什么区别？]]></content>
  </entry>
  <entry>
    <title><![CDATA[碎碎念]]></title>
    <url>%2F2017%2F10%2F01%2Fself-talking%2F</url>
    <content type="text"><![CDATA[2017-10-1 10:13:53我认为一个人成功，几个因素很重要：出身是起点（例如首富家的撕葱），好的平台能事半功倍，格局决定能到达的高度，另外是后天努力和方法得当。 2017-10-1 23:06:21识时务者为俊杰，一个人的成功，还要考虑到国家的政策和历史的进程，看得懂未来的人才能把握未来，顺应历史潮流和时代发展方向才有未来。当然，有些人可能并不懂这些，但也成功了，我认为可以归功于他们的运气，但归根还是他们的偶然的选择选对了，根本上还是顺应了历史潮流和时代发展方向。 2017-10-3 17:36:44很多人沉醉于过去的片刻辉煌，一个好的高中，一个好的大学，一个某奖杯，一个男/女朋友，过去的荣耀只属于过去，过去了的就让它过去吧。开心的事是这样，悲伤的过往也是如此。生命不息，拼搏不止。 2017-10-11 21:41:28“天下熙熙，皆为利来；天下攘攘，皆为利往。”那些人，熬夜写稿子，通宵改bug，没有节假日，没有休息，压抑痛苦，为什么？为了多赚钱，终极目标是获得自由，有人总结过：链接，从低到高，依次是菜场自由、餐厅自由、旅游自由、汽车自由、学校自由、工作自由、医疗自由、房产自由、国籍自由。自由的好处，在于你可以有选择权。然而人存于世，真正需要多少资源来满足自己的合理需求的，不多的，“良田千倾不过一日三餐，广厦万间只睡卧榻三尺”，如果一个人修身到足够的高度，他就能清楚知道自己想要什么样的生活，那么对于他来说，选择权有那么重要吗，他不需要更多的机会了，只要自己需要的唯一就可以了。清心寡欲，人生自然会少很多痛苦。面对人生的痛苦，要么多赚钱，让自己有更多的选择自由，要么让自己少些选择的欲望，这一切，书本会给你。 富家不用买良田，书中自有千钟粟。安居不用架高楼，书中自有黄金屋。娶妻莫恨无良媒，书中自有颜如玉。出门莫恨无人随，书中车马多如簇。男儿欲遂平生志，五经勤向窗前读。 2017-10-13 9:27:59软件最大的优点在于复用今天看了个特别有意思的视频： 从不同的尺度看世界：10亿光年到0.1飞米 2017-10-13 16:09:59“工作是为了解决问题，有些时候需要程序解决而已”，这是作为一个程序员的价值所在。永远记得程序员需要解决问题，创造价值，这是根本目的，研究技术可以是爱好，但绝不是目的。 2017-10-21 22:38:53之前看一些大牛的博客，顺便去关注了他们的微博，也没设备注，也没设分组，后来清理关注，清理了一些不记得什么原因去关注的人。于是我决定要设备注，设一个分组“程序员”，我是想让自己进一步接近真正的程序员，知道他们的平时生活，有朝一日也许我也能成为真正的程序员。仰慕大神，以至于在微博关注大神时都心有不安，因为一般有人关注时会有消息提示，我责备自己不该去打扰大神。 2017-10-22 20:13:41知乎中关注了一波清北的话题，虽然那群人离我很远，但看看他们的聊天还是很有意思的，能让自己多体会体会与最顶端的学生的差距。在以前，top学生给人一种很神秘的感觉，这种优秀似乎是上天赋予的，他们平时在想些什么，做些什么，父母是怎么教育的，高中大学是怎么度过的，我是很想知道的，但是圈子不同，差距太大，他们不愿意搭理我。现在的社交媒体给了我这样的机会，真是幸甚。成功的道路并不拥挤：最近迷上了github，大名鼎鼎的linux内核，11年9月初就把linux内核发布到github了，至今6年有余了，可是fork数只有区区19k。 2017-10-24 8:57:01凡事用进废退，记得刚上大学时打字很不习惯，一个是输入法选择强迫症，另外自己也不怎么写代码，也不怎么聊天，所以很久很久，打字很生疏，尤其是开始用五笔时，打字很慢，都没有写字快，然后克服了这个问题，归根是要多练习。同理我现在对linux的学习，包括对技术的学习，也是同样的道理，我有信心。 2017-10-25 8:44:20我觉得自己对网络相关的技术有特殊的兴趣，看技术博客时，每到网络相关的，什么vpn，ssh之类的，我会兴趣大增，先收藏关注下再说。倘若读研时读了网络相关的方向，我相信我是会有成果的。 2017-10-27 9:34:47空有远大抱负不行，还要有强悍的执行力。 2017-10-27 11:42:54共享单车，使用足够便捷，所以改变了我们的生活。同理，学习linux以及英语，之前没能坚持下来，也是因为学得磕磕绊绊，一个问题就成了拦路虎，打击了学习的热情。学习的热情很重要，相当于是汽车的燃料，燃料足的时候，抓紧时间向前跑，遇到问题热情下降时，就跑慢点，当走得足够远时，信心会越来越强。 2017-11-30 21:22:31用了一些很牛的软件，例如eclipse、idea、sublime等，网上很多教程，教人如何配置，从而可以方便高效地使用工具。还有一类文章中，作者把自己的工具配置文件共享了出来，这就是在使用工具上到了一个新的层次，本机配好了，用得爽，倘若换了台机器呢？倘若重装系统了呢？倘若换了个操作系统呢？倘若想分享给别人呢？你看，人的需求会不断升级，其实，很多软件、很多网站的架构也要根据使用场景的细致划分而逐渐升级，目标是，能随时随地高效简便地使用计算机。 2018-1-19 14:51:06没有经历过生死的人不足以放下手中的沙砾。 2018-1-20 21:14:45知乎上有位大咖，人称轮子哥，专业造轮子。我近来才意识到，作为一个程序员，造轮子是件很重要的事，所谓做项目，其实和建筑工人盖楼是一样的道理，盖楼需要很多零部件，平时要有意去搜集。github上的很多开源项目就是别人盖好的楼，进去观摩一番后，除了学习别人的精巧设计思想，以后自己盖楼时可以参考借鉴，一些好用的零部件可以直接顺走，放在自己的后备箱中，以备不时之需。别人的零部件，在加入自己后备箱前，要多了解了解，需要的话加以适当的改进，对这个零部件越是熟悉，个人定制化改造得越好，以后自己要盖楼时用起来越是省时顺溜。 2018-1-24 15:49:04突然感觉张震岳和冯唐长得像。 2018-2-2 16:05:15有容德乃大，无求品自高。 2018-2-6 20:53:53“到达终点没有捷径，但总有人比我们到的早”——张开涛。当我还在学习oauth2，一脸苦涩时，早在4年前，大咖 张开涛 第十七章 OAuth2集成——《跟我学Shiro》 和 阮一峰 理解OAuth 2.0 就已经发过博文对oauth2进行深入介绍。我再看oauth2的发布历史： Google在2011年3月宣布Google API对OAuth 2.0的支持。 OAuth 2.0的草案在2011年5月初在IETF发布。 2012年10月，OAuth 2.0协议正式发布为RFC 6749。 我是想说明啥呢，“莫道君行早，更有早行人”，有些人，有些公司的眼光远比一般人，比普通公司前瞻性要强。所以多关注那些聪明的人，聪明的公司，他们做的事，也许当前并不是热门，但可能是下一个热点。 2018-4-14 12:54:0微信有个截图的功能非常方便，之前是QQ有个截图功能很多人用。截图是个非常常用的工具，但系统自带的这个工具其实并不方便。那时候个人电脑还不是非常普及，有人到电脑室，第一步就是先登录自己的QQ，因为QQ除了提供截图的功能很方便，还有网盘等。这样的便利使得在那个特定的中国互联网时代，QQ得到了极大的普及。360安全卫士也是如此，其实像这些基础工程，要是微软做操作系统时就一揽子做好了，就没有QQ和360什么事了。]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java消息中间件]]></title>
    <url>%2F2017%2F09%2F30%2Fjms%2F</url>
    <content type="text"><![CDATA[什么是中间件非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来传值的软件统称为中间件。 什么是消息中间件关注于数据的发送和接受，利用高效可靠的异步消息传递机制集成分布式系统。 什么是JMSJava消息服务（Java Message Service）即JMS，是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 常用的消息中间件1.ActiveMQActiveMQ是一个完全支持JMS1.1和J2EE1.4规范的JMS Provider实现。 2.RabbitMQRabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写。安装rabbitmq前须要先安装erlang，我的安装目录是/usr/local/erlang20安装rabbitmq完成后，启动rabbitmq，报了个错： 1/usr/local/rabbitmq/bin/rabbitmq-server: line 50: erl: command not found 解决办法是，将erlang的erl软连接到/usr/bin目录下： ln -s /usr/local/erlang20/bin/erl /usr/bin/erl 然后再启动rabbitmq就正常了。 rabbitmq的页面管理系统：访问15672端口 3.KafkaKafka是一种高吞吐量的分布式发布订阅消息系统，是一个分布式的、分区的、可靠的分布式日志存储服务。Kafka不是一个严格的消息中间件，主要是用来作为日志存储的。对于海量的消息存储能保持长时间的稳定性能，高吞吐量。 三种消息中间件的比较： JMS接口之间的关系 JMS和MQ的关系JMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。而MQ则是消息队列服务，是面向消息中间件（MOM）的最终实现，是真正的服务提供者；MQ的实现可以基于JMS，也可以基于其他规范或标准。 参考 慕课网-Java消息中间件 MQ、JMS以及ActiveMQ 关系的理解]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悲伤的故事]]></title>
    <url>%2F2017%2F09%2F28%2Fbad-msg%2F</url>
    <content type="text"><![CDATA[Q:人生最悲伤的事情是什么？A:为了安全，给一文件加密码，最后自己也不记得密码了。]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[印象笔记试用]]></title>
    <url>%2F2017%2F09%2F27%2Fevernote-use%2F</url>
    <content type="text"><![CDATA[拖拽一个txt文件到印象笔记编辑页面，可以将页面内容提取出来，置于印象笔记编辑区。如下图：]]></content>
      <tags>
        <tag>evernote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习使用intellij idea]]></title>
    <url>%2F2017%2F09%2F25%2Fintellij-idea%2F</url>
    <content type="text"><![CDATA[快捷键首先，在idea的编辑界面给了几个有用的快捷键： 重命名文件：alt+shift+r 最大化窗口：ctrl+shift+f12 错误处理建议：ctrl+f12 删除当前行：ctrl+d 复制当前行并插入在当前行的下面：ctrl+y 打开 file structure 视图，查看类下所有的方法：alt+7 Postfix completion 后缀补全设置：使用：按下Enter键或Tab键就得到了： 简写 sout ：System.out.println(); psvm ：public static void main(String[] args) { } fori :for循环 idea 和 eclipse的区别IntelliJ系中的 Project 相当于Eclipse系中的 Workspace ；IntelliJ系中的 Module 相当于Eclipse系中的 Project ；IntelliJ中一个 Project 可以包括多个 Module ；Eclipse中一个 Workspace 可以包括多个 Project；idea和eclipse的一些概念上的映射关系： 问题在左侧的project目录中看不到项目的文件结构图，只能看到几个idea自己生成的文件：http://bbs.csdn.net/topics/390852723按下列步骤操作：1.关闭IDEA2.然后删除项目文件夹下的.idea文件夹3.重新用IDEA工具打开项目# gets stuck on “Copying resources”启动一个javaweb项目，半天启不起来，一直卡在”Copying resources”，我看任务管理器，磁盘100%，应该是在重新编译程序，关掉idea，重新打开，我点“Rebuild Project”，症状和前面相同，是不是电脑出问题了，我用安全卫士清理了一下电脑，然后重启电脑，然后像前面一样，启动tomcat，问题和之前一样，我打开工程中的target文件夹，发现编译得到的class文件以嵌套递归的形式存在于文件系统中，看了下target文件夹大小，170MB。解决办法：关闭idea，到工程目录下手动删掉target文件夹，然后重新打开idea，然后启动tomcat，成功。查看target文件夹大小，70MB。所以之前出现的问题，在于编译时生成文件到文件系统出错了，原因可能是idea的bug？ @Override is not allowed when implementing interface method参考： 链接 参考 极客学院-intellij idea版本控制]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建微信小程序]]></title>
    <url>%2F2017%2F09%2F25%2Fwe-app%2F</url>
    <content type="text"><![CDATA[2017-9-25 14:08:36昨天我的小程序审核通过了，纪念一下。搜索“qgchouDemo”。 继续学习小程序2018年1月5号，在腾讯云买了个微信小程序的后台解决方案2个月的，资源总览见参考9。之前学小程序时，没在腾讯云买解决方案，在网上搜个了可用的域名填了上去，虽然这里提示域名未备案：现在既然花了钱，就改成了腾讯云为我生成的域名。 买了解决方案后，在小程序的腾讯云解决方案的资源视图下，“二级域名与证书”模块中提示要及时更换一级域名，“目前已不支持直接使用 qcloud.la 域名（除 socket 域名外）发布小程序，请及时更换一级域名，以免影响小程序正式发布”，我把这个解决方案绑定了我的域名qgchou.cn，但是qgchou.cn只进行了实名认证，没有进行备案，奇怪，qgchou.top是在阿里云购买的，居然在域名绑定界面的域名列表中看到qgchou.top。域名没备案，想要使用服务器提供的网络交互功能，必须要备案才行，开始时我没弄懂，文档中说要配置服务器上的一个配置文件，我改了改，示例没跑通，于是决定先把配置文件还原，糟了，不记得原来是怎么写的了。于是我在腾讯云主机列表中，找到我的会话服务器和业务服务器，选择了重装系统，我以前重装系统后，小程序解决方案的一些配置文件就会还原，结果我错了，重装系统，就把原来已配好的后台程序全清除了，然后就又僵住了。一个教训是，尝试着改文件前，先把原文件备份一个，最坏的情况，自己没尝试成功，好歹不会把事情弄得更糟。 要么人受罪，要么钱受罪。得，耗不起，1月6号下午我新买了个解决方案1个月的，恶心的是一个腾讯云账号一次只能有一个正在使用的小程序解决方案，于是我再去申请了一个腾讯云账号，然后确定问题的原因的确是没备案，1月8号下午去照相，开始走备案流，等审核。 域名备案通过1.25号晚上10点半，终于收到短信和邮件，域名审核通过，域名审核的过程其实一点也不复杂，按腾讯云或阿里云上的提醒一步步来就行了。今天1月27号，还有10天我的这个解决方案就到期了，抓紧时间学学。 参考10和参考13，微信官方给了小程序的样例，分为客户端代码和服务器代码，买的解决方案已经部署有服务器端的程序了，只用把客户端程序下载到本地，导入“微信web开发者工具”。 按参考11，分别设置业务服务器上的配置文件sdk.config，以及客户端程序中的配置文件config.js，就可以了，sdk.config中只用改serverHost和tunnelServerUrl，其他项不用改。咦，我按参考11做的，点聊天室怎么进不去啊，点登录也报错。后来，我再去研究服务端配置文件，在/etc/qcloud目录下有个文件init_config.sh，我看看这脚本写的啥，最后是两句，重启tomcat和apache： 12systemctl restart tomcatsystemctl restart httpd 误打误撞，客户端程序能跑通了。其实上面遇到问题，最应该做的是去看日志！ 开心！ 参考 小程序介绍 小程序开发指南 简易计算器小程序wxapp-sCalc 剖析简易计算器带你入门微信小程序开发 微信公众平台 体验微信小程序 微信小程序解决方案 基于 CentOS 搭建微信小程序服务 腾讯云资源总览 腾讯云微信小程序使用教程 域名变更后的操作指引 腾讯云-小程序解决方案产品文档 资源初始化指引——微信小程序]]></content>
      <tags>
        <tag>we-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习使用markdown编辑器（补充）]]></title>
    <url>%2F2017%2F09%2F22%2Fmarkdown-other%2F</url>
    <content type="text"><![CDATA[可以使用&lt; font color=red /&gt;标签设置字体的颜色等红色蓝色 利用反斜杠来插入一些在语法中有其它意义的符号Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 字体样式 引用如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。在引用文字前加上 &gt; 并与文字保留一个字符的空格，即可。 链接和图片链接：在 Markdown 中，插入链接只需要使用 [显示文本](链接地址) 即可。图片：在 Markdown 中，插入图片只需要使用 ![显示文本](图片链接地址) 即可。 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可分割两段文字内容。 code模式按下四个空格，自动转入Code模式 this is code hello! 分段和换行两个回车是分段，两个空格加上一个回车是回车 列表列表分为有序列表和无序列表两种。无序列表使用星号、加号或是减号作为列表标记，有序列表则使用数字接着一个英文句点，在列表标记上使用的数字并不会影响输出的 HTML 结果，也就是说三条有序记录前面都用“1.”开始，显示出来后仍是“1.”、“2.”、“3.”。 参考 用 Markdown 写作用什么文本编辑器？ 有道云笔记Markdown指南 Markdown 语法整理大集合2017 MarkDown编辑器中缩进 Markdown 语法说明 (简体中文版) Markdown: Basics （快速入门）]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习使用markdown编辑器]]></title>
    <url>%2F2017%2F09%2F21%2Fmarkdown-use%2F</url>
    <content type="text"><![CDATA[拷贝来自：https://www.zybuluo.com/mdeditor如有侵权请告知我觉得这个页面对于学习markdown很有帮助 欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 [@ghosert][3]2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 参考 Cmd Markdown 编辑阅读器 Cmd-Markdown-高阶语法手册 MathJax basic tutorial and quick reference]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习使用git]]></title>
    <url>%2F2017%2F09%2F21%2Fgit-use%2F</url>
    <content type="text"><![CDATA[官方文档git命令的参数如何使用，见参考7，这是官方文档。英文不好？有中文文档，见参考11。 将服务器代码更到本地git checkout -- file1.md （该命令表示，把file1.md文件在工作区的修改全部撤销） git pull origin master （取回远程主机origin的master分支，与本地的当前分支合并） 上面的： git pull origin master 很常用！ 测试ssh是否添加成功ssh -T git@github.com 从github克隆项目到本地git clone -o github https://github.com/XXXXXXXX(仓库的地址) 下载指定分支的代码： git clone -b branch1 https://github.com/XXXXXXXX 本地有修改，要更新到服务器查看本地修改的文件：git status git add . 提交到本地仓库：git commit -m &quot;log&quot; 将本地仓库文件提交到github：git push origin master 将本地项目提交到github首先在本地新建一个git项目： mkdir test cd test git init touch README git add READMEgit commit -m ‘first commit’ git commit是将本地项目提交到本地仓库，本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要设置一下： ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，可以用git remote add命令将 “https://github.com/XXX/test.git” 设置为本地仓库的远程仓库，在本地test仓库的命令行输入： git remote add origin https://github.com/XXX/test.git （git remote add 命令用于添加远程主机），上面操作后git会自动将 https://github.com/XXX/test.git 远程名称设置为origin。git remote add命令可以为本地仓库设置多个远程仓库，例如我先后添加了两个远程仓库： 12$ git remote add origin https://github.com/XXX/XXXX.git$ git remote add origin2 https://gitee.com/YYY/YYYY.git 然后在仓库的配置文件.git/config中就能看到两条配置： [remote &quot;origin&quot;] url = https://github.com/XXX/XXXX.git fetch = +refs/heads/*:refs/remotes/origin/* [remote &quot;origin2&quot;] url = https://gitee.com/YYY/YYYY.git fetch = +refs/heads/*:refs/remotes/origin2/* 添加多个仓库是有应用场景的，比如我们在github上看到一个公开仓库，git clone下来后，自己改了改，然后觉得写的东西不好，想放在码云的私有仓库里，就可以先在码云建一个空的私有仓库，然后按上面的操作把 git clone 下来的改后的工程先关联到码云的私有仓库，然后 git push 到码云仓库。关联好之后我们就可以把本地库的所有内容推送到名称为origin的远程仓库（也就是Github）上了，通过： git push -u origin master 远程仓库不为空时，可能会报错提示“hint: Updates were rejected because the tip of your current branch is behind”，办法： git push -u -f origin master 加参数-f表示将本地仓库覆盖远程仓库，-f 参数是 –force 的简写。第一次push时加-u参数，这个参数是 –set-upstream 的简写，可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来要从远程仓库获取内容时，直接： git pull 本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。 一些命令的用法git操作涉及四个位置，本地工作树、暂存区、本地仓库、远程仓库。 git add本地进行编辑修改后，修改只是存在于本地工作树，git add命令用于将本地工作树中的修改加入到暂存区（Stage或者Index）中。暂存区是提交之前的一个临时区域。 git push$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; git push origin master： 表示将本地的master分支推送到远程origin主机注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如， 取回origin主机的next分支，与本地的master分支合并，需要写成下面这样：git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略： git pull origin next git log查看提交历史：只查看与某文件相关的日志： git log README.md 加上参数-p，文件的前后差别就会显示在提交信息之后： git log -p 如果只想看某个提交日志前后的差别： git log -p file1.md git diff查看当前工作树与暂存区的具体差别，看打印日志，可以观察发现，git log -p相当于是git log与git diff的结合。如果要看本地工作树与本地仓库最新记录的区别： git diff HEAD 如果要看某个文件相对于暂存区的具体修改，即那些还没有 git add 操作的文件，可以通过： git diff -w file1.md git reset –hard commit_idgit撤销commit本地删除一个文件，git commit后，还没有push。我觉得不应该删掉，于是执行上文中的命令，先是git log，能看到所有git commit的记录，然后用git reset –hard commit_id，回到指定的位置，操作后，删掉的文件又回来了。有趣的事，git reset操作后，我再看git log，最近的一次失误commit记录没有了。 git branch testBranch创建名为testBranch的分支，直接git branch，则是显示分支一览表，分支左侧标有星号（*）表示这是当前所在的分支。 git checkout testBranch切换到testBranch分支，创建testBranch分支并切换到该分支的另一种写法： git checkout -b testBranch git checkout file1.md关于git checkout的用法之二：git add之前，git status显示文件file1.md做了修改，如果要舍弃掉本地对file1.md的修改，执行git checkout file1.md，则文件file1.md恢复到原来版本。 git remote用于管理远程仓库，见参考8。 添加远程仓库git remote add [shortname] [url] 删除远程仓库（解除与远程仓库的关系）git remote rm [shortname] 查看某个远程仓库信息git remote show [shortname] 列出所有的远程仓库详细信息git remote -v -v是--verbose的简写 查看当前分支的upstream123$ git branch -vv main aaf02f0 [main/master: ahead 25] Some other commit* master add0a03 [jdsumsion/master] Some commit 下面是参考7的官方文档上git branch命令的参数说明： -v -vv --verbose When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the name of the upstream branch, as well (see also git remote show &lt;remote&gt;). 所以在使用 git push 命令推送到远程仓库前，先做个例行检查： git branch -vv 看看upstream是哪个，例如是origin2。 git remote show origin2，看看这个远程仓库的详细信息，核验一下远程仓库的地址有没有错。 git config参考链接10，这个命令用于查看以及修改 git 配置。config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local 底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件。 查看配置信息查看所有配置信息： git config -l 查看系统配置： git config --system --list 查看当前用户的配置： git config --global --list 查看当前仓库的配置： git config --local --list 编码配置避免git gui中的中文乱码： git config --global gui.encoding utf-8 避免git status显示的中文文件名乱码： git config --global core.quotepath off git修改提交的用户名和Emailgit config --global user.name &quot;Your Name&quot; git config --global user.email you@example.com 全局的通过vim ~/.gitconfig来查看，可以直接编辑该文件修改提交的用户名和Email。windows下这个文件的地址是： 我的git管理的项目既有公司的项目，也有自己的项目。这两套我想用不同的签名信息。配置信息时用 local 参数就可以啦。 –local 参数只能作用于一个仓库里面。 例如： git config --local user.name &quot;Your Name&quot; git config --local user.email you@example.com 这样就设置了当前仓库的签名，其他仓库还是用全局的签名。 在本分支下修改文件之前合并主分支git merge origin master 版本标签tag一般是生成一个大版本时要创建个tag： git tag tag123 将这个tag提交到远程： git push origin tag123 删除未监视的文件 untracked files# 删除 untracked files git clean -f # 连 untracked 的目录也一起删掉 git clean -fd GitHub Desktop挺好用的，可以在图形化界面显示当前版本的修改情况，可以方便进行还原，方便选择要推送到仓库的文件。 码云eclipse编辑器中的一个项目想到托管在码云，步骤见参考5，相比于github，码云最大的好处是可以建私有仓库。一些见不得人的代码可以放在码云私有库。后来在idea下有个项目，也想托管在码云，没有找到特别好的图形化操作教程，在慕课网的一个课程上，老师用命令行教我提交一个idea下的项目，见参考6。先在码云新建一个仓库，地址 https://gitee.com/XXX/YYY.git ，然后到项目所在目录，创建.gitignore文件，然后就是上文中说了很多次的一些命令，git init，git add，git commit，这样就将当前项目提交到了本地仓库。然后与远程仓库进行关联： git remote add origin https://gitee.com/XXX/YYY.git 然后进行git push操作，将本地仓库内容推送到远程仓库，这一步操作可能会提示要先更新本地仓库，先git pull即可。也可以不git pull，用本地仓库内容覆盖远程仓库内容，git push加个参数-f即可： git push -u -f origin master 如何切换到服务器上的一个分支以idea下的操作为例，打开 Terminal，先 git pull 拉取服务器上的所有分支，然后checkout 切换到指定分支： 撤销已commit，但未git push的操作见参考12 其他让git不要管windows/unix换行符转换的事：git config –global core.autocrlf false 常见错误代码冲突服务器上的代码与本地的修改有冲突，参考 Git:代码冲突常见解决方法： error: Your local changes to the following files would be overwritten by merge: protected/config/main.php Please, commit your changes or stash them before you can merge. 参考 Git远程操作详解 如何将本地项目上传到github 如何在 Git 里撤销(几乎)任何操作 git checkout 命令详解 使用eclipse自带git插件托管项目到”码云” 慕课网-git初始化 Git-Documentation Git–Remote远程仓库的使用 git 如何查看当前分支的upstream? GIT-查看config配置信息 Git-Documentation 中文版 git撤销commit，但未git push的命令]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
